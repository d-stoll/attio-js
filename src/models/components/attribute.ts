/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  OutputValue,
  OutputValue$inboundSchema,
  OutputValue$Outbound,
  OutputValue$outboundSchema,
} from "./outputvalue.js";

export type AttributeId = {
  /**
   * A UUID representing the workspace this attribute belongs to.
   */
  workspaceId: string;
  /**
   * A UUID to identify the object or list that this attribute belongs to
   */
  objectId: string;
  /**
   * A UUID to identify this attribute.
   */
  attributeId: string;
};

/**
 * The type of the attribute.
 */
export const AttributeType = {
  Text: "text",
  Number: "number",
  Checkbox: "checkbox",
  Currency: "currency",
  Date: "date",
  Timestamp: "timestamp",
  Rating: "rating",
  Status: "status",
  Select: "select",
  RecordReference: "record-reference",
  ActorReference: "actor-reference",
  Location: "location",
  Domain: "domain",
  EmailAddress: "email-address",
  PhoneNumber: "phone-number",
  Interaction: "interaction",
  PersonalName: "personal-name",
} as const;
/**
 * The type of the attribute.
 */
export type AttributeType = ClosedEnum<typeof AttributeType>;

export const TypeStatic = {
  Static: "static",
} as const;
export type TypeStatic = ClosedEnum<typeof TypeStatic>;

export type DefaultValueStatic = {
  type: TypeStatic;
  template: Array<OutputValue>;
};

export const TypeDynamic = {
  Dynamic: "dynamic",
} as const;
export type TypeDynamic = ClosedEnum<typeof TypeDynamic>;

/**
 * For actor reference attributes, you may pass a dynamic value of `"current-user"`. When creating new records or entries, this will cause the actor reference value to be populated with either the workspace member or API token that created the record/entry.
 */
export const Template = {
  CurrentUser: "current-user",
} as const;
/**
 * For actor reference attributes, you may pass a dynamic value of `"current-user"`. When creating new records or entries, this will cause the actor reference value to be populated with either the workspace member or API token that created the record/entry.
 */
export type Template = ClosedEnum<typeof Template>;

export type DefaultValueDynamic = {
  type: TypeDynamic;
  template?: any | undefined;
};

/**
 * The default value for this attribute. Static values are used to directly populate values using their contents. Dynamic values are used to lookup data at the point of creation. For example, you could use a dynamic value to insert a value for the currently logged in user. Which default values are available is dependent on the type of the attribute.
 */
export type DefaultValue = DefaultValueDynamic | DefaultValueStatic;

export type RelationshipId = {
  /**
   * A UUID representing the workspace this attribute belongs to.
   */
  workspaceId: string;
  /**
   * A UUID to identify the object or list that this attribute belongs to
   */
  objectId: string;
  /**
   * A UUID to identify this attribute.
   */
  attributeId: string;
};

/**
 * If this attribute is related to another attribute, this is an object that includes an `id` property that identifies the other attribute. `null` means no relationship exists. See [the help center](https://attio.com/help/reference/managing-your-data/attributes#relationship-attributes) for more details about relationship attributes.
 */
export type Relationship = {
  id: RelationshipId;
};

/**
 * The ISO4217 code representing the currency that values for this attribute should be stored in.
 */
export const DefaultCurrencyCode = {
  Aud: "AUD",
  Brl: "BRL",
  Bel: "BEL",
  Cad: "CAD",
  Cny: "CNY",
  Cop: "COP",
  Czk: "CZK",
  Dkk: "DKK",
  Eur: "EUR",
  Hkd: "HKD",
  Isk: "ISK",
  Inr: "INR",
  Ils: "ILS",
  Jpy: "JPY",
  Krw: "KRW",
  Myr: "MYR",
  Mxn: "MXN",
  Ntd: "NTD",
  Nzd: "NZD",
  Ngn: "NGN",
  Nok: "NOK",
  Xpf: "XPF",
  Pen: "PEN",
  Php: "PHP",
  Pln: "PLN",
  Gbp: "GBP",
  Sar: "SAR",
  Sgd: "SGD",
  Zar: "ZAR",
  Sek: "SEK",
  Chf: "CHF",
  Aed: "AED",
  Usd: "USD",
} as const;
/**
 * The ISO4217 code representing the currency that values for this attribute should be stored in.
 */
export type DefaultCurrencyCode = ClosedEnum<typeof DefaultCurrencyCode>;

/**
 * How the currency should be displayed across the app. "code" will display the ISO currency code e.g. "USD", "name" will display the localized currency name e.g. "British pound", "narrowSymbol" will display "$1" instead of "US$1" and "symbol" will display a localized currency symbol such as "$".
 */
export const DisplayType = {
  Code: "code",
  Name: "name",
  NarrowSymbol: "narrowSymbol",
  Symbol: "symbol",
} as const;
/**
 * How the currency should be displayed across the app. "code" will display the ISO currency code e.g. "USD", "name" will display the localized currency name e.g. "British pound", "narrowSymbol" will display "$1" instead of "US$1" and "symbol" will display a localized currency symbol such as "$".
 */
export type DisplayType = ClosedEnum<typeof DisplayType>;

/**
 * Configuration available for attributes of type "currency".
 */
export type Currency = {
  /**
   * The ISO4217 code representing the currency that values for this attribute should be stored in.
   */
  defaultCurrencyCode: DefaultCurrencyCode | null;
  /**
   * How the currency should be displayed across the app. "code" will display the ISO currency code e.g. "USD", "name" will display the localized currency name e.g. "British pound", "narrowSymbol" will display "$1" instead of "US$1" and "symbol" will display a localized currency symbol such as "$".
   */
  displayType: DisplayType | null;
};

/**
 * Configuration available for attributes of type "record-reference".
 */
export type RecordReference = {
  /**
   * A list of UUIDs to indicate which objects records are allowed to belong to. Leave empty to to allow records from all object types.
   */
  allowedObjectIds: Array<string> | null;
};

/**
 * Additional, type-dependent configuration for the attribute.
 */
export type Config = {
  /**
   * Configuration available for attributes of type "currency".
   */
  currency: Currency;
  /**
   * Configuration available for attributes of type "record-reference".
   */
  recordReference: RecordReference;
};

export type Attribute = {
  id: AttributeId;
  /**
   * A title for the attribute, to be displayed across the app.
   */
  title: string;
  /**
   * A text description of the attribute.
   */
  description: string | null;
  /**
   * A unique slug for the attribute for use in API responses and URLs. Formatted in snake case.
   */
  apiSlug: string;
  /**
   * The type of the attribute.
   */
  type: AttributeType;
  /**
   * `true` if this is an Attio system-defined attribute, `false` if defined by a user or non-Attio system.
   */
  isSystemAttribute: boolean;
  /**
   * Whether or not this attribute can be written to. Can only be false when `is_system_attribute` is `true` (user-defined attributes are always writeable). If `false`, this usually means the attribute is enriched by Attio.
   */
  isWritable: boolean;
  /**
   * When `is_required` is `true`, new records/entries must have a value for this attribute. If `false`, values may be `null`. This value does not affect existing data and you do not need to backfill `null` values if changing `is_required` from `false` to `true`.
   */
  isRequired: boolean;
  /**
   * Whether or not new values for this attribute must be unique. Uniqueness restrictions are only applied to new data and do not apply retroactively to previously created data.
   */
  isUnique: boolean;
  /**
   * Whether or not this attribute can have multiple values. Multiselect is only available on some value types.
   */
  isMultiselect: boolean;
  /**
   * Whether this attribute has a default value enabled. Must be `true` when `is_required` is `true`.
   */
  isDefaultValueEnabled: boolean;
  /**
   * Whether this attribute has been archived. Archived attributes are hidden from most UI, but can be restored either over the API or in workspace settings. See the [guide on archiving and deleting](/docs/archiving-vs-deleting)for more information.
   */
  isArchived: boolean;
  /**
   * The default value for this attribute. Static values are used to directly populate values using their contents. Dynamic values are used to lookup data at the point of creation. For example, you could use a dynamic value to insert a value for the currently logged in user. Which default values are available is dependent on the type of the attribute.
   */
  defaultValue: DefaultValueDynamic | DefaultValueStatic | null;
  /**
   * If this attribute is related to another attribute, this is an object that includes an `id` property that identifies the other attribute. `null` means no relationship exists. See [the help center](https://attio.com/help/reference/managing-your-data/attributes#relationship-attributes) for more details about relationship attributes.
   */
  relationship: Relationship | null;
  /**
   * When this attribute was created.
   */
  createdAt: string;
  /**
   * Additional, type-dependent configuration for the attribute.
   */
  config: Config;
};

/** @internal */
export const AttributeId$inboundSchema: z.ZodType<
  AttributeId,
  z.ZodTypeDef,
  unknown
> = z.object({
  workspace_id: z.string(),
  object_id: z.string(),
  attribute_id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "workspace_id": "workspaceId",
    "object_id": "objectId",
    "attribute_id": "attributeId",
  });
});

/** @internal */
export type AttributeId$Outbound = {
  workspace_id: string;
  object_id: string;
  attribute_id: string;
};

/** @internal */
export const AttributeId$outboundSchema: z.ZodType<
  AttributeId$Outbound,
  z.ZodTypeDef,
  AttributeId
> = z.object({
  workspaceId: z.string(),
  objectId: z.string(),
  attributeId: z.string(),
}).transform((v) => {
  return remap$(v, {
    workspaceId: "workspace_id",
    objectId: "object_id",
    attributeId: "attribute_id",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AttributeId$ {
  /** @deprecated use `AttributeId$inboundSchema` instead. */
  export const inboundSchema = AttributeId$inboundSchema;
  /** @deprecated use `AttributeId$outboundSchema` instead. */
  export const outboundSchema = AttributeId$outboundSchema;
  /** @deprecated use `AttributeId$Outbound` instead. */
  export type Outbound = AttributeId$Outbound;
}

export function attributeIdToJSON(attributeId: AttributeId): string {
  return JSON.stringify(AttributeId$outboundSchema.parse(attributeId));
}

export function attributeIdFromJSON(
  jsonString: string,
): SafeParseResult<AttributeId, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AttributeId$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AttributeId' from JSON`,
  );
}

/** @internal */
export const AttributeType$inboundSchema: z.ZodNativeEnum<
  typeof AttributeType
> = z.nativeEnum(AttributeType);

/** @internal */
export const AttributeType$outboundSchema: z.ZodNativeEnum<
  typeof AttributeType
> = AttributeType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AttributeType$ {
  /** @deprecated use `AttributeType$inboundSchema` instead. */
  export const inboundSchema = AttributeType$inboundSchema;
  /** @deprecated use `AttributeType$outboundSchema` instead. */
  export const outboundSchema = AttributeType$outboundSchema;
}

/** @internal */
export const TypeStatic$inboundSchema: z.ZodNativeEnum<typeof TypeStatic> = z
  .nativeEnum(TypeStatic);

/** @internal */
export const TypeStatic$outboundSchema: z.ZodNativeEnum<typeof TypeStatic> =
  TypeStatic$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeStatic$ {
  /** @deprecated use `TypeStatic$inboundSchema` instead. */
  export const inboundSchema = TypeStatic$inboundSchema;
  /** @deprecated use `TypeStatic$outboundSchema` instead. */
  export const outboundSchema = TypeStatic$outboundSchema;
}

/** @internal */
export const DefaultValueStatic$inboundSchema: z.ZodType<
  DefaultValueStatic,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: TypeStatic$inboundSchema,
  template: z.array(OutputValue$inboundSchema),
});

/** @internal */
export type DefaultValueStatic$Outbound = {
  type: string;
  template: Array<OutputValue$Outbound>;
};

/** @internal */
export const DefaultValueStatic$outboundSchema: z.ZodType<
  DefaultValueStatic$Outbound,
  z.ZodTypeDef,
  DefaultValueStatic
> = z.object({
  type: TypeStatic$outboundSchema,
  template: z.array(OutputValue$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DefaultValueStatic$ {
  /** @deprecated use `DefaultValueStatic$inboundSchema` instead. */
  export const inboundSchema = DefaultValueStatic$inboundSchema;
  /** @deprecated use `DefaultValueStatic$outboundSchema` instead. */
  export const outboundSchema = DefaultValueStatic$outboundSchema;
  /** @deprecated use `DefaultValueStatic$Outbound` instead. */
  export type Outbound = DefaultValueStatic$Outbound;
}

export function defaultValueStaticToJSON(
  defaultValueStatic: DefaultValueStatic,
): string {
  return JSON.stringify(
    DefaultValueStatic$outboundSchema.parse(defaultValueStatic),
  );
}

export function defaultValueStaticFromJSON(
  jsonString: string,
): SafeParseResult<DefaultValueStatic, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DefaultValueStatic$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DefaultValueStatic' from JSON`,
  );
}

/** @internal */
export const TypeDynamic$inboundSchema: z.ZodNativeEnum<typeof TypeDynamic> = z
  .nativeEnum(TypeDynamic);

/** @internal */
export const TypeDynamic$outboundSchema: z.ZodNativeEnum<typeof TypeDynamic> =
  TypeDynamic$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeDynamic$ {
  /** @deprecated use `TypeDynamic$inboundSchema` instead. */
  export const inboundSchema = TypeDynamic$inboundSchema;
  /** @deprecated use `TypeDynamic$outboundSchema` instead. */
  export const outboundSchema = TypeDynamic$outboundSchema;
}

/** @internal */
export const Template$inboundSchema: z.ZodNativeEnum<typeof Template> = z
  .nativeEnum(Template);

/** @internal */
export const Template$outboundSchema: z.ZodNativeEnum<typeof Template> =
  Template$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Template$ {
  /** @deprecated use `Template$inboundSchema` instead. */
  export const inboundSchema = Template$inboundSchema;
  /** @deprecated use `Template$outboundSchema` instead. */
  export const outboundSchema = Template$outboundSchema;
}

/** @internal */
export const DefaultValueDynamic$inboundSchema: z.ZodType<
  DefaultValueDynamic,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: TypeDynamic$inboundSchema,
  template: z.any().optional(),
});

/** @internal */
export type DefaultValueDynamic$Outbound = {
  type: string;
  template?: any | undefined;
};

/** @internal */
export const DefaultValueDynamic$outboundSchema: z.ZodType<
  DefaultValueDynamic$Outbound,
  z.ZodTypeDef,
  DefaultValueDynamic
> = z.object({
  type: TypeDynamic$outboundSchema,
  template: z.any().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DefaultValueDynamic$ {
  /** @deprecated use `DefaultValueDynamic$inboundSchema` instead. */
  export const inboundSchema = DefaultValueDynamic$inboundSchema;
  /** @deprecated use `DefaultValueDynamic$outboundSchema` instead. */
  export const outboundSchema = DefaultValueDynamic$outboundSchema;
  /** @deprecated use `DefaultValueDynamic$Outbound` instead. */
  export type Outbound = DefaultValueDynamic$Outbound;
}

export function defaultValueDynamicToJSON(
  defaultValueDynamic: DefaultValueDynamic,
): string {
  return JSON.stringify(
    DefaultValueDynamic$outboundSchema.parse(defaultValueDynamic),
  );
}

export function defaultValueDynamicFromJSON(
  jsonString: string,
): SafeParseResult<DefaultValueDynamic, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DefaultValueDynamic$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DefaultValueDynamic' from JSON`,
  );
}

/** @internal */
export const DefaultValue$inboundSchema: z.ZodType<
  DefaultValue,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => DefaultValueDynamic$inboundSchema),
  z.lazy(() => DefaultValueStatic$inboundSchema),
]);

/** @internal */
export type DefaultValue$Outbound =
  | DefaultValueDynamic$Outbound
  | DefaultValueStatic$Outbound;

/** @internal */
export const DefaultValue$outboundSchema: z.ZodType<
  DefaultValue$Outbound,
  z.ZodTypeDef,
  DefaultValue
> = z.union([
  z.lazy(() => DefaultValueDynamic$outboundSchema),
  z.lazy(() => DefaultValueStatic$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DefaultValue$ {
  /** @deprecated use `DefaultValue$inboundSchema` instead. */
  export const inboundSchema = DefaultValue$inboundSchema;
  /** @deprecated use `DefaultValue$outboundSchema` instead. */
  export const outboundSchema = DefaultValue$outboundSchema;
  /** @deprecated use `DefaultValue$Outbound` instead. */
  export type Outbound = DefaultValue$Outbound;
}

export function defaultValueToJSON(defaultValue: DefaultValue): string {
  return JSON.stringify(DefaultValue$outboundSchema.parse(defaultValue));
}

export function defaultValueFromJSON(
  jsonString: string,
): SafeParseResult<DefaultValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DefaultValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DefaultValue' from JSON`,
  );
}

/** @internal */
export const RelationshipId$inboundSchema: z.ZodType<
  RelationshipId,
  z.ZodTypeDef,
  unknown
> = z.object({
  workspace_id: z.string(),
  object_id: z.string(),
  attribute_id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "workspace_id": "workspaceId",
    "object_id": "objectId",
    "attribute_id": "attributeId",
  });
});

/** @internal */
export type RelationshipId$Outbound = {
  workspace_id: string;
  object_id: string;
  attribute_id: string;
};

/** @internal */
export const RelationshipId$outboundSchema: z.ZodType<
  RelationshipId$Outbound,
  z.ZodTypeDef,
  RelationshipId
> = z.object({
  workspaceId: z.string(),
  objectId: z.string(),
  attributeId: z.string(),
}).transform((v) => {
  return remap$(v, {
    workspaceId: "workspace_id",
    objectId: "object_id",
    attributeId: "attribute_id",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RelationshipId$ {
  /** @deprecated use `RelationshipId$inboundSchema` instead. */
  export const inboundSchema = RelationshipId$inboundSchema;
  /** @deprecated use `RelationshipId$outboundSchema` instead. */
  export const outboundSchema = RelationshipId$outboundSchema;
  /** @deprecated use `RelationshipId$Outbound` instead. */
  export type Outbound = RelationshipId$Outbound;
}

export function relationshipIdToJSON(relationshipId: RelationshipId): string {
  return JSON.stringify(RelationshipId$outboundSchema.parse(relationshipId));
}

export function relationshipIdFromJSON(
  jsonString: string,
): SafeParseResult<RelationshipId, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RelationshipId$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RelationshipId' from JSON`,
  );
}

/** @internal */
export const Relationship$inboundSchema: z.ZodType<
  Relationship,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.lazy(() => RelationshipId$inboundSchema),
});

/** @internal */
export type Relationship$Outbound = {
  id: RelationshipId$Outbound;
};

/** @internal */
export const Relationship$outboundSchema: z.ZodType<
  Relationship$Outbound,
  z.ZodTypeDef,
  Relationship
> = z.object({
  id: z.lazy(() => RelationshipId$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Relationship$ {
  /** @deprecated use `Relationship$inboundSchema` instead. */
  export const inboundSchema = Relationship$inboundSchema;
  /** @deprecated use `Relationship$outboundSchema` instead. */
  export const outboundSchema = Relationship$outboundSchema;
  /** @deprecated use `Relationship$Outbound` instead. */
  export type Outbound = Relationship$Outbound;
}

export function relationshipToJSON(relationship: Relationship): string {
  return JSON.stringify(Relationship$outboundSchema.parse(relationship));
}

export function relationshipFromJSON(
  jsonString: string,
): SafeParseResult<Relationship, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Relationship$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Relationship' from JSON`,
  );
}

/** @internal */
export const DefaultCurrencyCode$inboundSchema: z.ZodNativeEnum<
  typeof DefaultCurrencyCode
> = z.nativeEnum(DefaultCurrencyCode);

/** @internal */
export const DefaultCurrencyCode$outboundSchema: z.ZodNativeEnum<
  typeof DefaultCurrencyCode
> = DefaultCurrencyCode$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DefaultCurrencyCode$ {
  /** @deprecated use `DefaultCurrencyCode$inboundSchema` instead. */
  export const inboundSchema = DefaultCurrencyCode$inboundSchema;
  /** @deprecated use `DefaultCurrencyCode$outboundSchema` instead. */
  export const outboundSchema = DefaultCurrencyCode$outboundSchema;
}

/** @internal */
export const DisplayType$inboundSchema: z.ZodNativeEnum<typeof DisplayType> = z
  .nativeEnum(DisplayType);

/** @internal */
export const DisplayType$outboundSchema: z.ZodNativeEnum<typeof DisplayType> =
  DisplayType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DisplayType$ {
  /** @deprecated use `DisplayType$inboundSchema` instead. */
  export const inboundSchema = DisplayType$inboundSchema;
  /** @deprecated use `DisplayType$outboundSchema` instead. */
  export const outboundSchema = DisplayType$outboundSchema;
}

/** @internal */
export const Currency$inboundSchema: z.ZodType<
  Currency,
  z.ZodTypeDef,
  unknown
> = z.object({
  default_currency_code: z.nullable(DefaultCurrencyCode$inboundSchema),
  display_type: z.nullable(DisplayType$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "default_currency_code": "defaultCurrencyCode",
    "display_type": "displayType",
  });
});

/** @internal */
export type Currency$Outbound = {
  default_currency_code: string | null;
  display_type: string | null;
};

/** @internal */
export const Currency$outboundSchema: z.ZodType<
  Currency$Outbound,
  z.ZodTypeDef,
  Currency
> = z.object({
  defaultCurrencyCode: z.nullable(DefaultCurrencyCode$outboundSchema),
  displayType: z.nullable(DisplayType$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    defaultCurrencyCode: "default_currency_code",
    displayType: "display_type",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Currency$ {
  /** @deprecated use `Currency$inboundSchema` instead. */
  export const inboundSchema = Currency$inboundSchema;
  /** @deprecated use `Currency$outboundSchema` instead. */
  export const outboundSchema = Currency$outboundSchema;
  /** @deprecated use `Currency$Outbound` instead. */
  export type Outbound = Currency$Outbound;
}

export function currencyToJSON(currency: Currency): string {
  return JSON.stringify(Currency$outboundSchema.parse(currency));
}

export function currencyFromJSON(
  jsonString: string,
): SafeParseResult<Currency, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Currency$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Currency' from JSON`,
  );
}

/** @internal */
export const RecordReference$inboundSchema: z.ZodType<
  RecordReference,
  z.ZodTypeDef,
  unknown
> = z.object({
  allowed_object_ids: z.nullable(z.array(z.string())),
}).transform((v) => {
  return remap$(v, {
    "allowed_object_ids": "allowedObjectIds",
  });
});

/** @internal */
export type RecordReference$Outbound = {
  allowed_object_ids: Array<string> | null;
};

/** @internal */
export const RecordReference$outboundSchema: z.ZodType<
  RecordReference$Outbound,
  z.ZodTypeDef,
  RecordReference
> = z.object({
  allowedObjectIds: z.nullable(z.array(z.string())),
}).transform((v) => {
  return remap$(v, {
    allowedObjectIds: "allowed_object_ids",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RecordReference$ {
  /** @deprecated use `RecordReference$inboundSchema` instead. */
  export const inboundSchema = RecordReference$inboundSchema;
  /** @deprecated use `RecordReference$outboundSchema` instead. */
  export const outboundSchema = RecordReference$outboundSchema;
  /** @deprecated use `RecordReference$Outbound` instead. */
  export type Outbound = RecordReference$Outbound;
}

export function recordReferenceToJSON(
  recordReference: RecordReference,
): string {
  return JSON.stringify(RecordReference$outboundSchema.parse(recordReference));
}

export function recordReferenceFromJSON(
  jsonString: string,
): SafeParseResult<RecordReference, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RecordReference$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RecordReference' from JSON`,
  );
}

/** @internal */
export const Config$inboundSchema: z.ZodType<Config, z.ZodTypeDef, unknown> = z
  .object({
    currency: z.lazy(() => Currency$inboundSchema),
    record_reference: z.lazy(() => RecordReference$inboundSchema),
  }).transform((v) => {
    return remap$(v, {
      "record_reference": "recordReference",
    });
  });

/** @internal */
export type Config$Outbound = {
  currency: Currency$Outbound;
  record_reference: RecordReference$Outbound;
};

/** @internal */
export const Config$outboundSchema: z.ZodType<
  Config$Outbound,
  z.ZodTypeDef,
  Config
> = z.object({
  currency: z.lazy(() => Currency$outboundSchema),
  recordReference: z.lazy(() => RecordReference$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    recordReference: "record_reference",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Config$ {
  /** @deprecated use `Config$inboundSchema` instead. */
  export const inboundSchema = Config$inboundSchema;
  /** @deprecated use `Config$outboundSchema` instead. */
  export const outboundSchema = Config$outboundSchema;
  /** @deprecated use `Config$Outbound` instead. */
  export type Outbound = Config$Outbound;
}

export function configToJSON(config: Config): string {
  return JSON.stringify(Config$outboundSchema.parse(config));
}

export function configFromJSON(
  jsonString: string,
): SafeParseResult<Config, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Config$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Config' from JSON`,
  );
}

/** @internal */
export const Attribute$inboundSchema: z.ZodType<
  Attribute,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.lazy(() => AttributeId$inboundSchema),
  title: z.string(),
  description: z.nullable(z.string()),
  api_slug: z.string(),
  type: AttributeType$inboundSchema,
  is_system_attribute: z.boolean(),
  is_writable: z.boolean(),
  is_required: z.boolean(),
  is_unique: z.boolean(),
  is_multiselect: z.boolean(),
  is_default_value_enabled: z.boolean(),
  is_archived: z.boolean(),
  default_value: z.nullable(
    z.union([
      z.lazy(() => DefaultValueDynamic$inboundSchema),
      z.lazy(() => DefaultValueStatic$inboundSchema),
    ]),
  ),
  relationship: z.nullable(z.lazy(() => Relationship$inboundSchema)),
  created_at: z.string(),
  config: z.lazy(() => Config$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "api_slug": "apiSlug",
    "is_system_attribute": "isSystemAttribute",
    "is_writable": "isWritable",
    "is_required": "isRequired",
    "is_unique": "isUnique",
    "is_multiselect": "isMultiselect",
    "is_default_value_enabled": "isDefaultValueEnabled",
    "is_archived": "isArchived",
    "default_value": "defaultValue",
    "created_at": "createdAt",
  });
});

/** @internal */
export type Attribute$Outbound = {
  id: AttributeId$Outbound;
  title: string;
  description: string | null;
  api_slug: string;
  type: string;
  is_system_attribute: boolean;
  is_writable: boolean;
  is_required: boolean;
  is_unique: boolean;
  is_multiselect: boolean;
  is_default_value_enabled: boolean;
  is_archived: boolean;
  default_value:
    | DefaultValueDynamic$Outbound
    | DefaultValueStatic$Outbound
    | null;
  relationship: Relationship$Outbound | null;
  created_at: string;
  config: Config$Outbound;
};

/** @internal */
export const Attribute$outboundSchema: z.ZodType<
  Attribute$Outbound,
  z.ZodTypeDef,
  Attribute
> = z.object({
  id: z.lazy(() => AttributeId$outboundSchema),
  title: z.string(),
  description: z.nullable(z.string()),
  apiSlug: z.string(),
  type: AttributeType$outboundSchema,
  isSystemAttribute: z.boolean(),
  isWritable: z.boolean(),
  isRequired: z.boolean(),
  isUnique: z.boolean(),
  isMultiselect: z.boolean(),
  isDefaultValueEnabled: z.boolean(),
  isArchived: z.boolean(),
  defaultValue: z.nullable(
    z.union([
      z.lazy(() => DefaultValueDynamic$outboundSchema),
      z.lazy(() => DefaultValueStatic$outboundSchema),
    ]),
  ),
  relationship: z.nullable(z.lazy(() => Relationship$outboundSchema)),
  createdAt: z.string(),
  config: z.lazy(() => Config$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    apiSlug: "api_slug",
    isSystemAttribute: "is_system_attribute",
    isWritable: "is_writable",
    isRequired: "is_required",
    isUnique: "is_unique",
    isMultiselect: "is_multiselect",
    isDefaultValueEnabled: "is_default_value_enabled",
    isArchived: "is_archived",
    defaultValue: "default_value",
    createdAt: "created_at",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Attribute$ {
  /** @deprecated use `Attribute$inboundSchema` instead. */
  export const inboundSchema = Attribute$inboundSchema;
  /** @deprecated use `Attribute$outboundSchema` instead. */
  export const outboundSchema = Attribute$outboundSchema;
  /** @deprecated use `Attribute$Outbound` instead. */
  export type Outbound = Attribute$Outbound;
}

export function attributeToJSON(attribute: Attribute): string {
  return JSON.stringify(Attribute$outboundSchema.parse(attribute));
}

export function attributeFromJSON(
  jsonString: string,
): SafeParseResult<Attribute, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Attribute$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Attribute' from JSON`,
  );
}
