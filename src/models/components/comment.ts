/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type CommentId = {
  /**
   * The ID of the workspace the comment belongs to.
   */
  workspaceId: string;
  /**
   * The ID of the comment.
   */
  commentId: string;
};

/**
 * The entry the comment belongs to, `null` for comments on records.
 */
export type Entry = {
  /**
   * The ID of the entry the comment belongs to.
   */
  entryId: string;
  /**
   * The ID of the list the entry belongs to.
   */
  listId: string;
};

/**
 * The record the comment belongs to.
 */
export type RecordT = {
  /**
   * The ID of the record the comment belongs to.
   */
  recordId: string;
  /**
   * The ID of the object the record belongs to.
   */
  objectId: string;
};

/**
 * The type of actor. [Read more information on actor types here](/docs/actors).
 */
export const CommentType = {
  ApiToken: "api-token",
  WorkspaceMember: "workspace-member",
  System: "system",
  App: "app",
} as const;
/**
 * The type of actor. [Read more information on actor types here](/docs/actors).
 */
export type CommentType = ClosedEnum<typeof CommentType>;

/**
 * The actor that resolved this comment.
 */
export type ResolvedBy = {
  /**
   * An ID to identify the actor.
   */
  id?: string | null | undefined;
  /**
   * The type of actor. [Read more information on actor types here](/docs/actors).
   */
  type?: CommentType | null | undefined;
};

/**
 * The type of actor. [Read more information on actor types here](/docs/actors).
 */
export const CommentAuthorType = {
  ApiToken: "api-token",
  WorkspaceMember: "workspace-member",
  System: "system",
  App: "app",
} as const;
/**
 * The type of actor. [Read more information on actor types here](/docs/actors).
 */
export type CommentAuthorType = ClosedEnum<typeof CommentAuthorType>;

/**
 * Who wrote this comment. Note that the API provides the ability for API tokens to write comments on behalf of other actors.
 */
export type Author = {
  /**
   * An ID to identify the actor.
   */
  id?: string | null | undefined;
  /**
   * The type of actor. [Read more information on actor types here](/docs/actors).
   */
  type?: CommentAuthorType | null | undefined;
};

export type Comment = {
  id: CommentId;
  /**
   * The ID of the thread the comment belongs to.
   */
  threadId: string;
  /**
   * A plaintext representation of the content of the comment. References to workspace members are cast into email addresses, all other stylistic elements are removed.
   */
  contentPlaintext: string;
  /**
   * The entry the comment belongs to, `null` for comments on records.
   */
  entry: Entry | null;
  /**
   * The record the comment belongs to.
   */
  record: RecordT;
  /**
   * Whether the comment is resolved.
   */
  resolvedAt: string | null;
  /**
   * The actor that resolved this comment.
   */
  resolvedBy: ResolvedBy;
  /**
   * When the note was created.
   */
  createdAt: string;
  /**
   * Who wrote this comment. Note that the API provides the ability for API tokens to write comments on behalf of other actors.
   */
  author: Author;
};

/** @internal */
export const CommentId$inboundSchema: z.ZodType<
  CommentId,
  z.ZodTypeDef,
  unknown
> = z.object({
  workspace_id: z.string(),
  comment_id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "workspace_id": "workspaceId",
    "comment_id": "commentId",
  });
});

/** @internal */
export type CommentId$Outbound = {
  workspace_id: string;
  comment_id: string;
};

/** @internal */
export const CommentId$outboundSchema: z.ZodType<
  CommentId$Outbound,
  z.ZodTypeDef,
  CommentId
> = z.object({
  workspaceId: z.string(),
  commentId: z.string(),
}).transform((v) => {
  return remap$(v, {
    workspaceId: "workspace_id",
    commentId: "comment_id",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CommentId$ {
  /** @deprecated use `CommentId$inboundSchema` instead. */
  export const inboundSchema = CommentId$inboundSchema;
  /** @deprecated use `CommentId$outboundSchema` instead. */
  export const outboundSchema = CommentId$outboundSchema;
  /** @deprecated use `CommentId$Outbound` instead. */
  export type Outbound = CommentId$Outbound;
}

export function commentIdToJSON(commentId: CommentId): string {
  return JSON.stringify(CommentId$outboundSchema.parse(commentId));
}

export function commentIdFromJSON(
  jsonString: string,
): SafeParseResult<CommentId, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CommentId$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CommentId' from JSON`,
  );
}

/** @internal */
export const Entry$inboundSchema: z.ZodType<Entry, z.ZodTypeDef, unknown> = z
  .object({
    entry_id: z.string(),
    list_id: z.string(),
  }).transform((v) => {
    return remap$(v, {
      "entry_id": "entryId",
      "list_id": "listId",
    });
  });

/** @internal */
export type Entry$Outbound = {
  entry_id: string;
  list_id: string;
};

/** @internal */
export const Entry$outboundSchema: z.ZodType<
  Entry$Outbound,
  z.ZodTypeDef,
  Entry
> = z.object({
  entryId: z.string(),
  listId: z.string(),
}).transform((v) => {
  return remap$(v, {
    entryId: "entry_id",
    listId: "list_id",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Entry$ {
  /** @deprecated use `Entry$inboundSchema` instead. */
  export const inboundSchema = Entry$inboundSchema;
  /** @deprecated use `Entry$outboundSchema` instead. */
  export const outboundSchema = Entry$outboundSchema;
  /** @deprecated use `Entry$Outbound` instead. */
  export type Outbound = Entry$Outbound;
}

export function entryToJSON(entry: Entry): string {
  return JSON.stringify(Entry$outboundSchema.parse(entry));
}

export function entryFromJSON(
  jsonString: string,
): SafeParseResult<Entry, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Entry$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Entry' from JSON`,
  );
}

/** @internal */
export const RecordT$inboundSchema: z.ZodType<RecordT, z.ZodTypeDef, unknown> =
  z.object({
    record_id: z.string(),
    object_id: z.string(),
  }).transform((v) => {
    return remap$(v, {
      "record_id": "recordId",
      "object_id": "objectId",
    });
  });

/** @internal */
export type RecordT$Outbound = {
  record_id: string;
  object_id: string;
};

/** @internal */
export const RecordT$outboundSchema: z.ZodType<
  RecordT$Outbound,
  z.ZodTypeDef,
  RecordT
> = z.object({
  recordId: z.string(),
  objectId: z.string(),
}).transform((v) => {
  return remap$(v, {
    recordId: "record_id",
    objectId: "object_id",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RecordT$ {
  /** @deprecated use `RecordT$inboundSchema` instead. */
  export const inboundSchema = RecordT$inboundSchema;
  /** @deprecated use `RecordT$outboundSchema` instead. */
  export const outboundSchema = RecordT$outboundSchema;
  /** @deprecated use `RecordT$Outbound` instead. */
  export type Outbound = RecordT$Outbound;
}

export function recordToJSON(recordT: RecordT): string {
  return JSON.stringify(RecordT$outboundSchema.parse(recordT));
}

export function recordFromJSON(
  jsonString: string,
): SafeParseResult<RecordT, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RecordT$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RecordT' from JSON`,
  );
}

/** @internal */
export const CommentType$inboundSchema: z.ZodNativeEnum<typeof CommentType> = z
  .nativeEnum(CommentType);

/** @internal */
export const CommentType$outboundSchema: z.ZodNativeEnum<typeof CommentType> =
  CommentType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CommentType$ {
  /** @deprecated use `CommentType$inboundSchema` instead. */
  export const inboundSchema = CommentType$inboundSchema;
  /** @deprecated use `CommentType$outboundSchema` instead. */
  export const outboundSchema = CommentType$outboundSchema;
}

/** @internal */
export const ResolvedBy$inboundSchema: z.ZodType<
  ResolvedBy,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.nullable(z.string()).optional(),
  type: z.nullable(CommentType$inboundSchema).optional(),
});

/** @internal */
export type ResolvedBy$Outbound = {
  id?: string | null | undefined;
  type?: string | null | undefined;
};

/** @internal */
export const ResolvedBy$outboundSchema: z.ZodType<
  ResolvedBy$Outbound,
  z.ZodTypeDef,
  ResolvedBy
> = z.object({
  id: z.nullable(z.string()).optional(),
  type: z.nullable(CommentType$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResolvedBy$ {
  /** @deprecated use `ResolvedBy$inboundSchema` instead. */
  export const inboundSchema = ResolvedBy$inboundSchema;
  /** @deprecated use `ResolvedBy$outboundSchema` instead. */
  export const outboundSchema = ResolvedBy$outboundSchema;
  /** @deprecated use `ResolvedBy$Outbound` instead. */
  export type Outbound = ResolvedBy$Outbound;
}

export function resolvedByToJSON(resolvedBy: ResolvedBy): string {
  return JSON.stringify(ResolvedBy$outboundSchema.parse(resolvedBy));
}

export function resolvedByFromJSON(
  jsonString: string,
): SafeParseResult<ResolvedBy, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResolvedBy$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResolvedBy' from JSON`,
  );
}

/** @internal */
export const CommentAuthorType$inboundSchema: z.ZodNativeEnum<
  typeof CommentAuthorType
> = z.nativeEnum(CommentAuthorType);

/** @internal */
export const CommentAuthorType$outboundSchema: z.ZodNativeEnum<
  typeof CommentAuthorType
> = CommentAuthorType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CommentAuthorType$ {
  /** @deprecated use `CommentAuthorType$inboundSchema` instead. */
  export const inboundSchema = CommentAuthorType$inboundSchema;
  /** @deprecated use `CommentAuthorType$outboundSchema` instead. */
  export const outboundSchema = CommentAuthorType$outboundSchema;
}

/** @internal */
export const Author$inboundSchema: z.ZodType<Author, z.ZodTypeDef, unknown> = z
  .object({
    id: z.nullable(z.string()).optional(),
    type: z.nullable(CommentAuthorType$inboundSchema).optional(),
  });

/** @internal */
export type Author$Outbound = {
  id?: string | null | undefined;
  type?: string | null | undefined;
};

/** @internal */
export const Author$outboundSchema: z.ZodType<
  Author$Outbound,
  z.ZodTypeDef,
  Author
> = z.object({
  id: z.nullable(z.string()).optional(),
  type: z.nullable(CommentAuthorType$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Author$ {
  /** @deprecated use `Author$inboundSchema` instead. */
  export const inboundSchema = Author$inboundSchema;
  /** @deprecated use `Author$outboundSchema` instead. */
  export const outboundSchema = Author$outboundSchema;
  /** @deprecated use `Author$Outbound` instead. */
  export type Outbound = Author$Outbound;
}

export function authorToJSON(author: Author): string {
  return JSON.stringify(Author$outboundSchema.parse(author));
}

export function authorFromJSON(
  jsonString: string,
): SafeParseResult<Author, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Author$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Author' from JSON`,
  );
}

/** @internal */
export const Comment$inboundSchema: z.ZodType<Comment, z.ZodTypeDef, unknown> =
  z.object({
    id: z.lazy(() => CommentId$inboundSchema),
    thread_id: z.string(),
    content_plaintext: z.string(),
    entry: z.nullable(z.lazy(() => Entry$inboundSchema)),
    record: z.lazy(() => RecordT$inboundSchema),
    resolved_at: z.nullable(z.string()),
    resolved_by: z.lazy(() => ResolvedBy$inboundSchema),
    created_at: z.string(),
    author: z.lazy(() => Author$inboundSchema),
  }).transform((v) => {
    return remap$(v, {
      "thread_id": "threadId",
      "content_plaintext": "contentPlaintext",
      "resolved_at": "resolvedAt",
      "resolved_by": "resolvedBy",
      "created_at": "createdAt",
    });
  });

/** @internal */
export type Comment$Outbound = {
  id: CommentId$Outbound;
  thread_id: string;
  content_plaintext: string;
  entry: Entry$Outbound | null;
  record: RecordT$Outbound;
  resolved_at: string | null;
  resolved_by: ResolvedBy$Outbound;
  created_at: string;
  author: Author$Outbound;
};

/** @internal */
export const Comment$outboundSchema: z.ZodType<
  Comment$Outbound,
  z.ZodTypeDef,
  Comment
> = z.object({
  id: z.lazy(() => CommentId$outboundSchema),
  threadId: z.string(),
  contentPlaintext: z.string(),
  entry: z.nullable(z.lazy(() => Entry$outboundSchema)),
  record: z.lazy(() => RecordT$outboundSchema),
  resolvedAt: z.nullable(z.string()),
  resolvedBy: z.lazy(() => ResolvedBy$outboundSchema),
  createdAt: z.string(),
  author: z.lazy(() => Author$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    threadId: "thread_id",
    contentPlaintext: "content_plaintext",
    resolvedAt: "resolved_at",
    resolvedBy: "resolved_by",
    createdAt: "created_at",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Comment$ {
  /** @deprecated use `Comment$inboundSchema` instead. */
  export const inboundSchema = Comment$inboundSchema;
  /** @deprecated use `Comment$outboundSchema` instead. */
  export const outboundSchema = Comment$outboundSchema;
  /** @deprecated use `Comment$Outbound` instead. */
  export type Outbound = Comment$Outbound;
}

export function commentToJSON(comment: Comment): string {
  return JSON.stringify(Comment$outboundSchema.parse(comment));
}

export function commentFromJSON(
  jsonString: string,
): SafeParseResult<Comment, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Comment$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Comment' from JSON`,
  );
}
