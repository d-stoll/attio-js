/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as components from "../components/index.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The format of the task content to be created. Rich text formatting, links and @references are not supported.
 */
export const PostV2TasksFormat = {
  Plaintext: "plaintext",
} as const;
/**
 * The format of the task content to be created. Rich text formatting, links and @references are not supported.
 */
export type PostV2TasksFormat = ClosedEnum<typeof PostV2TasksFormat>;

export type Five = {
  /**
   * A raw text field. Values are limited to 10MB.
   */
  value?: string | undefined;
};

/**
 * The ISO 3166-1 alpha-2 country code representing the country that this phone number belongs to.
 */
export const CountryCode = {
  Af: "AF",
  Ax: "AX",
  Al: "AL",
  Dz: "DZ",
  As: "AS",
  Ad: "AD",
  Ao: "AO",
  Ai: "AI",
  Aq: "AQ",
  Ag: "AG",
  Ar: "AR",
  Am: "AM",
  Aw: "AW",
  Au: "AU",
  At: "AT",
  Az: "AZ",
  Bs: "BS",
  Bh: "BH",
  Bd: "BD",
  Bb: "BB",
  By: "BY",
  Be: "BE",
  Bz: "BZ",
  Bj: "BJ",
  Bm: "BM",
  Bt: "BT",
  Bo: "BO",
  Ba: "BA",
  Bw: "BW",
  Bv: "BV",
  Br: "BR",
  Io: "IO",
  Bn: "BN",
  Bg: "BG",
  Bf: "BF",
  Bi: "BI",
  Kh: "KH",
  Cm: "CM",
  Ca: "CA",
  Cv: "CV",
  Ky: "KY",
  Cf: "CF",
  Td: "TD",
  Cl: "CL",
  Cn: "CN",
  Cx: "CX",
  Cc: "CC",
  Co: "CO",
  Km: "KM",
  Cg: "CG",
  Cd: "CD",
  Ck: "CK",
  Cr: "CR",
  Ci: "CI",
  Hr: "HR",
  Cu: "CU",
  Cw: "CW",
  Cy: "CY",
  Cz: "CZ",
  Dk: "DK",
  Dj: "DJ",
  Dm: "DM",
  Do: "DO",
  Ec: "EC",
  Eg: "EG",
  Sv: "SV",
  Gq: "GQ",
  Er: "ER",
  Ee: "EE",
  Et: "ET",
  Fk: "FK",
  Fo: "FO",
  Fj: "FJ",
  Fi: "FI",
  Fr: "FR",
  Gf: "GF",
  Pf: "PF",
  Tf: "TF",
  Ga: "GA",
  Gm: "GM",
  Ge: "GE",
  De: "DE",
  Gh: "GH",
  Gi: "GI",
  Gr: "GR",
  Gl: "GL",
  Gd: "GD",
  Gp: "GP",
  Gu: "GU",
  Gt: "GT",
  Gg: "GG",
  Gn: "GN",
  Gw: "GW",
  Gy: "GY",
  Ht: "HT",
  Hm: "HM",
  Va: "VA",
  Hn: "HN",
  Hk: "HK",
  Hu: "HU",
  Is: "IS",
  In: "IN",
  Id: "ID",
  Ir: "IR",
  Iq: "IQ",
  Ie: "IE",
  Im: "IM",
  Il: "IL",
  It: "IT",
  Jm: "JM",
  Jp: "JP",
  Je: "JE",
  Jo: "JO",
  Kz: "KZ",
  Ke: "KE",
  Ki: "KI",
  Kr: "KR",
  Kw: "KW",
  Kg: "KG",
  La: "LA",
  Lv: "LV",
  Lb: "LB",
  Ls: "LS",
  Lr: "LR",
  Ly: "LY",
  Li: "LI",
  Lt: "LT",
  Lu: "LU",
  Mo: "MO",
  Mk: "MK",
  Mg: "MG",
  Mw: "MW",
  My: "MY",
  Mv: "MV",
  Ml: "ML",
  Mt: "MT",
  Mh: "MH",
  Mq: "MQ",
  Mr: "MR",
  Mu: "MU",
  Yt: "YT",
  Mx: "MX",
  Fm: "FM",
  Md: "MD",
  Mc: "MC",
  Mn: "MN",
  Me: "ME",
  Ms: "MS",
  Ma: "MA",
  Mz: "MZ",
  Mm: "MM",
  Na: "NA",
  Nr: "NR",
  Np: "NP",
  Nl: "NL",
  An: "AN",
  Nc: "NC",
  Nz: "NZ",
  Ni: "NI",
  Ne: "NE",
  Ng: "NG",
  Nu: "NU",
  Nf: "NF",
  Mp: "MP",
  No: "NO",
  Om: "OM",
  Pk: "PK",
  Pw: "PW",
  Ps: "PS",
  Pa: "PA",
  Pg: "PG",
  Py: "PY",
  Pe: "PE",
  Ph: "PH",
  Pn: "PN",
  Pl: "PL",
  Pt: "PT",
  Pr: "PR",
  Qa: "QA",
  Re: "RE",
  Ro: "RO",
  Ru: "RU",
  Rw: "RW",
  Bl: "BL",
  Sh: "SH",
  Kn: "KN",
  Lc: "LC",
  Mf: "MF",
  Pm: "PM",
  Vc: "VC",
  Ws: "WS",
  Sm: "SM",
  St: "ST",
  Sa: "SA",
  Sn: "SN",
  Ss: "SS",
  Rs: "RS",
  Sc: "SC",
  Sl: "SL",
  Sg: "SG",
  Sk: "SK",
  Si: "SI",
  Sb: "SB",
  So: "SO",
  Za: "ZA",
  Gs: "GS",
  Es: "ES",
  Lk: "LK",
  Sd: "SD",
  Sr: "SR",
  Sj: "SJ",
  Sz: "SZ",
  Se: "SE",
  Ch: "CH",
  Sy: "SY",
  Tw: "TW",
  Tj: "TJ",
  Tz: "TZ",
  Th: "TH",
  Tl: "TL",
  Tg: "TG",
  Tk: "TK",
  To: "TO",
  Tt: "TT",
  Tn: "TN",
  Tr: "TR",
  Tm: "TM",
  Tc: "TC",
  Tv: "TV",
  Ug: "UG",
  Ua: "UA",
  Ae: "AE",
  Gb: "GB",
  Us: "US",
  Um: "UM",
  Uy: "UY",
  Uz: "UZ",
  Vu: "VU",
  Ve: "VE",
  Vn: "VN",
  Vg: "VG",
  Vi: "VI",
  Wf: "WF",
  Eh: "EH",
  Ye: "YE",
  Zm: "ZM",
  Zw: "ZW",
} as const;
/**
 * The ISO 3166-1 alpha-2 country code representing the country that this phone number belongs to.
 */
export type CountryCode = ClosedEnum<typeof CountryCode>;

export type Four = {
  /**
   * The raw, original phone number, as inputted.
   */
  originalPhoneNumber?: string | undefined;
  /**
   * The ISO 3166-1 alpha-2 country code representing the country that this phone number belongs to.
   */
  countryCode?: CountryCode | null | undefined;
};

export type Three = {
  /**
   * Numbers are persisted as 64 bit floats.
   */
  value?: number | undefined;
};

export type SlugOrIdOfMatchingAttribute2 = {
  /**
   * An email address string
   */
  emailAddress?: string | undefined;
};

export type SlugOrIdOfMatchingAttribute1 = {
  /**
   * The full domain of the website.
   */
  domain?: string | undefined;
};

export type SlugOrIdOfMatchingAttribute =
  | SlugOrIdOfMatchingAttribute1
  | SlugOrIdOfMatchingAttribute2
  | Three
  | Five
  | Four;

export type LinkedRecords2 = {
  /**
   * A UUID or slug to identify the object that the referenced record belongs to.
   */
  targetObject: string;
  /**
   * In addition to referencing records directly by record ID, you may also reference by a matching attribute of your choice. For example, if you want to add a reference to the person record with email "alice@website.com", you should pass a value with `target_object` set to `"people"` and `email_addresses` set to `[{email_address:"alice@website.com"}]`. The key should be the slug or ID of the matching attribute you would like to use and the value should be an array containing a single value of the appropriate attribute type (as specified below). Matching on multiple values is not currently supported. Matching attributes must be unique. This process is similar to how you use the `matching_attribute` query param in Attio's [assert endpoints](/reference/put_v2-objects-object-records).
   */
  slugOrIdOfMatchingAttribute: Array<
    | SlugOrIdOfMatchingAttribute1
    | SlugOrIdOfMatchingAttribute2
    | Three
    | Five
    | Four
  >;
};

export type LinkedRecords1 = {
  /**
   * The ID or slug of the parent object the tasks refers to. This can reference both standard and custom objects.`
   */
  targetObject: string;
  /**
   * The ID of the parent record the task refers to.
   */
  targetRecordId: string;
};

export type LinkedRecords = LinkedRecords1 | LinkedRecords2;

export type Assignees2 = {
  /**
   * Workspace member actors can be referenced by email address as well as actor ID.
   */
  workspaceMemberEmailAddress: string;
};

/**
 * The actor type of the task assignee. Only `workspace-member` actors can be assigned to tasks. [Read more information on actor types here](/docs/actors).
 */
export const ReferencedActorType = {
  WorkspaceMember: "workspace-member",
} as const;
/**
 * The actor type of the task assignee. Only `workspace-member` actors can be assigned to tasks. [Read more information on actor types here](/docs/actors).
 */
export type ReferencedActorType = ClosedEnum<typeof ReferencedActorType>;

export type Assignees1 = {
  /**
   * The actor type of the task assignee. Only `workspace-member` actors can be assigned to tasks. [Read more information on actor types here](/docs/actors).
   */
  referencedActorType: ReferencedActorType;
  /**
   * The ID of the actor assigned to this task.
   */
  referencedActorId: string;
};

export type Assignees = Assignees2 | Assignees1;

export type PostV2TasksData = {
  /**
   * The text content of the task, in the format specified by the `format` property.
   */
  content: string;
  /**
   * The format of the task content to be created. Rich text formatting, links and @references are not supported.
   */
  format: PostV2TasksFormat;
  /**
   * The deadline of the task, in ISO 8601 format.
   */
  deadlineAt: string | null;
  /**
   * Whether the task has been completed.
   */
  isCompleted: boolean;
  /**
   * Records linked to the task. Creating record links within task content text is not possible via the API at present.
   */
  linkedRecords: Array<LinkedRecords1 | LinkedRecords2>;
  /**
   * Workspace members assigned to this task.
   */
  assignees: Array<Assignees2 | Assignees1>;
};

export type PostV2TasksRequestBody = {
  data: PostV2TasksData;
};

/**
 * Success
 */
export type PostV2TasksResponseBody = {
  data: components.Task;
};

/** @internal */
export const PostV2TasksFormat$inboundSchema: z.ZodNativeEnum<
  typeof PostV2TasksFormat
> = z.nativeEnum(PostV2TasksFormat);

/** @internal */
export const PostV2TasksFormat$outboundSchema: z.ZodNativeEnum<
  typeof PostV2TasksFormat
> = PostV2TasksFormat$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PostV2TasksFormat$ {
  /** @deprecated use `PostV2TasksFormat$inboundSchema` instead. */
  export const inboundSchema = PostV2TasksFormat$inboundSchema;
  /** @deprecated use `PostV2TasksFormat$outboundSchema` instead. */
  export const outboundSchema = PostV2TasksFormat$outboundSchema;
}

/** @internal */
export const Five$inboundSchema: z.ZodType<Five, z.ZodTypeDef, unknown> = z
  .object({
    value: z.string().optional(),
  });

/** @internal */
export type Five$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const Five$outboundSchema: z.ZodType<Five$Outbound, z.ZodTypeDef, Five> =
  z.object({
    value: z.string().optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Five$ {
  /** @deprecated use `Five$inboundSchema` instead. */
  export const inboundSchema = Five$inboundSchema;
  /** @deprecated use `Five$outboundSchema` instead. */
  export const outboundSchema = Five$outboundSchema;
  /** @deprecated use `Five$Outbound` instead. */
  export type Outbound = Five$Outbound;
}

export function fiveToJSON(five: Five): string {
  return JSON.stringify(Five$outboundSchema.parse(five));
}

export function fiveFromJSON(
  jsonString: string,
): SafeParseResult<Five, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Five$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Five' from JSON`,
  );
}

/** @internal */
export const CountryCode$inboundSchema: z.ZodNativeEnum<typeof CountryCode> = z
  .nativeEnum(CountryCode);

/** @internal */
export const CountryCode$outboundSchema: z.ZodNativeEnum<typeof CountryCode> =
  CountryCode$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CountryCode$ {
  /** @deprecated use `CountryCode$inboundSchema` instead. */
  export const inboundSchema = CountryCode$inboundSchema;
  /** @deprecated use `CountryCode$outboundSchema` instead. */
  export const outboundSchema = CountryCode$outboundSchema;
}

/** @internal */
export const Four$inboundSchema: z.ZodType<Four, z.ZodTypeDef, unknown> = z
  .object({
    original_phone_number: z.string().optional(),
    country_code: z.nullable(CountryCode$inboundSchema).optional(),
  }).transform((v) => {
    return remap$(v, {
      "original_phone_number": "originalPhoneNumber",
      "country_code": "countryCode",
    });
  });

/** @internal */
export type Four$Outbound = {
  original_phone_number?: string | undefined;
  country_code?: string | null | undefined;
};

/** @internal */
export const Four$outboundSchema: z.ZodType<Four$Outbound, z.ZodTypeDef, Four> =
  z.object({
    originalPhoneNumber: z.string().optional(),
    countryCode: z.nullable(CountryCode$outboundSchema).optional(),
  }).transform((v) => {
    return remap$(v, {
      originalPhoneNumber: "original_phone_number",
      countryCode: "country_code",
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Four$ {
  /** @deprecated use `Four$inboundSchema` instead. */
  export const inboundSchema = Four$inboundSchema;
  /** @deprecated use `Four$outboundSchema` instead. */
  export const outboundSchema = Four$outboundSchema;
  /** @deprecated use `Four$Outbound` instead. */
  export type Outbound = Four$Outbound;
}

export function fourToJSON(four: Four): string {
  return JSON.stringify(Four$outboundSchema.parse(four));
}

export function fourFromJSON(
  jsonString: string,
): SafeParseResult<Four, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Four$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Four' from JSON`,
  );
}

/** @internal */
export const Three$inboundSchema: z.ZodType<Three, z.ZodTypeDef, unknown> = z
  .object({
    value: z.number().optional(),
  });

/** @internal */
export type Three$Outbound = {
  value?: number | undefined;
};

/** @internal */
export const Three$outboundSchema: z.ZodType<
  Three$Outbound,
  z.ZodTypeDef,
  Three
> = z.object({
  value: z.number().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Three$ {
  /** @deprecated use `Three$inboundSchema` instead. */
  export const inboundSchema = Three$inboundSchema;
  /** @deprecated use `Three$outboundSchema` instead. */
  export const outboundSchema = Three$outboundSchema;
  /** @deprecated use `Three$Outbound` instead. */
  export type Outbound = Three$Outbound;
}

export function threeToJSON(three: Three): string {
  return JSON.stringify(Three$outboundSchema.parse(three));
}

export function threeFromJSON(
  jsonString: string,
): SafeParseResult<Three, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Three$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Three' from JSON`,
  );
}

/** @internal */
export const SlugOrIdOfMatchingAttribute2$inboundSchema: z.ZodType<
  SlugOrIdOfMatchingAttribute2,
  z.ZodTypeDef,
  unknown
> = z.object({
  email_address: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "email_address": "emailAddress",
  });
});

/** @internal */
export type SlugOrIdOfMatchingAttribute2$Outbound = {
  email_address?: string | undefined;
};

/** @internal */
export const SlugOrIdOfMatchingAttribute2$outboundSchema: z.ZodType<
  SlugOrIdOfMatchingAttribute2$Outbound,
  z.ZodTypeDef,
  SlugOrIdOfMatchingAttribute2
> = z.object({
  emailAddress: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    emailAddress: "email_address",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SlugOrIdOfMatchingAttribute2$ {
  /** @deprecated use `SlugOrIdOfMatchingAttribute2$inboundSchema` instead. */
  export const inboundSchema = SlugOrIdOfMatchingAttribute2$inboundSchema;
  /** @deprecated use `SlugOrIdOfMatchingAttribute2$outboundSchema` instead. */
  export const outboundSchema = SlugOrIdOfMatchingAttribute2$outboundSchema;
  /** @deprecated use `SlugOrIdOfMatchingAttribute2$Outbound` instead. */
  export type Outbound = SlugOrIdOfMatchingAttribute2$Outbound;
}

export function slugOrIdOfMatchingAttribute2ToJSON(
  slugOrIdOfMatchingAttribute2: SlugOrIdOfMatchingAttribute2,
): string {
  return JSON.stringify(
    SlugOrIdOfMatchingAttribute2$outboundSchema.parse(
      slugOrIdOfMatchingAttribute2,
    ),
  );
}

export function slugOrIdOfMatchingAttribute2FromJSON(
  jsonString: string,
): SafeParseResult<SlugOrIdOfMatchingAttribute2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SlugOrIdOfMatchingAttribute2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SlugOrIdOfMatchingAttribute2' from JSON`,
  );
}

/** @internal */
export const SlugOrIdOfMatchingAttribute1$inboundSchema: z.ZodType<
  SlugOrIdOfMatchingAttribute1,
  z.ZodTypeDef,
  unknown
> = z.object({
  domain: z.string().optional(),
});

/** @internal */
export type SlugOrIdOfMatchingAttribute1$Outbound = {
  domain?: string | undefined;
};

/** @internal */
export const SlugOrIdOfMatchingAttribute1$outboundSchema: z.ZodType<
  SlugOrIdOfMatchingAttribute1$Outbound,
  z.ZodTypeDef,
  SlugOrIdOfMatchingAttribute1
> = z.object({
  domain: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SlugOrIdOfMatchingAttribute1$ {
  /** @deprecated use `SlugOrIdOfMatchingAttribute1$inboundSchema` instead. */
  export const inboundSchema = SlugOrIdOfMatchingAttribute1$inboundSchema;
  /** @deprecated use `SlugOrIdOfMatchingAttribute1$outboundSchema` instead. */
  export const outboundSchema = SlugOrIdOfMatchingAttribute1$outboundSchema;
  /** @deprecated use `SlugOrIdOfMatchingAttribute1$Outbound` instead. */
  export type Outbound = SlugOrIdOfMatchingAttribute1$Outbound;
}

export function slugOrIdOfMatchingAttribute1ToJSON(
  slugOrIdOfMatchingAttribute1: SlugOrIdOfMatchingAttribute1,
): string {
  return JSON.stringify(
    SlugOrIdOfMatchingAttribute1$outboundSchema.parse(
      slugOrIdOfMatchingAttribute1,
    ),
  );
}

export function slugOrIdOfMatchingAttribute1FromJSON(
  jsonString: string,
): SafeParseResult<SlugOrIdOfMatchingAttribute1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SlugOrIdOfMatchingAttribute1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SlugOrIdOfMatchingAttribute1' from JSON`,
  );
}

/** @internal */
export const SlugOrIdOfMatchingAttribute$inboundSchema: z.ZodType<
  SlugOrIdOfMatchingAttribute,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => SlugOrIdOfMatchingAttribute1$inboundSchema),
  z.lazy(() => SlugOrIdOfMatchingAttribute2$inboundSchema),
  z.lazy(() => Three$inboundSchema),
  z.lazy(() => Five$inboundSchema),
  z.lazy(() => Four$inboundSchema),
]);

/** @internal */
export type SlugOrIdOfMatchingAttribute$Outbound =
  | SlugOrIdOfMatchingAttribute1$Outbound
  | SlugOrIdOfMatchingAttribute2$Outbound
  | Three$Outbound
  | Five$Outbound
  | Four$Outbound;

/** @internal */
export const SlugOrIdOfMatchingAttribute$outboundSchema: z.ZodType<
  SlugOrIdOfMatchingAttribute$Outbound,
  z.ZodTypeDef,
  SlugOrIdOfMatchingAttribute
> = z.union([
  z.lazy(() => SlugOrIdOfMatchingAttribute1$outboundSchema),
  z.lazy(() => SlugOrIdOfMatchingAttribute2$outboundSchema),
  z.lazy(() => Three$outboundSchema),
  z.lazy(() => Five$outboundSchema),
  z.lazy(() => Four$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SlugOrIdOfMatchingAttribute$ {
  /** @deprecated use `SlugOrIdOfMatchingAttribute$inboundSchema` instead. */
  export const inboundSchema = SlugOrIdOfMatchingAttribute$inboundSchema;
  /** @deprecated use `SlugOrIdOfMatchingAttribute$outboundSchema` instead. */
  export const outboundSchema = SlugOrIdOfMatchingAttribute$outboundSchema;
  /** @deprecated use `SlugOrIdOfMatchingAttribute$Outbound` instead. */
  export type Outbound = SlugOrIdOfMatchingAttribute$Outbound;
}

export function slugOrIdOfMatchingAttributeToJSON(
  slugOrIdOfMatchingAttribute: SlugOrIdOfMatchingAttribute,
): string {
  return JSON.stringify(
    SlugOrIdOfMatchingAttribute$outboundSchema.parse(
      slugOrIdOfMatchingAttribute,
    ),
  );
}

export function slugOrIdOfMatchingAttributeFromJSON(
  jsonString: string,
): SafeParseResult<SlugOrIdOfMatchingAttribute, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SlugOrIdOfMatchingAttribute$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SlugOrIdOfMatchingAttribute' from JSON`,
  );
}

/** @internal */
export const LinkedRecords2$inboundSchema: z.ZodType<
  LinkedRecords2,
  z.ZodTypeDef,
  unknown
> = z.object({
  target_object: z.string(),
  "[slug_or_id_of_matching_attribute]": z.array(
    z.union([
      z.lazy(() => SlugOrIdOfMatchingAttribute1$inboundSchema),
      z.lazy(() => SlugOrIdOfMatchingAttribute2$inboundSchema),
      z.lazy(() => Three$inboundSchema),
      z.lazy(() => Five$inboundSchema),
      z.lazy(() => Four$inboundSchema),
    ]),
  ),
}).transform((v) => {
  return remap$(v, {
    "target_object": "targetObject",
    "[slug_or_id_of_matching_attribute]": "slugOrIdOfMatchingAttribute",
  });
});

/** @internal */
export type LinkedRecords2$Outbound = {
  target_object: string;
  "[slug_or_id_of_matching_attribute]": Array<
    | SlugOrIdOfMatchingAttribute1$Outbound
    | SlugOrIdOfMatchingAttribute2$Outbound
    | Three$Outbound
    | Five$Outbound
    | Four$Outbound
  >;
};

/** @internal */
export const LinkedRecords2$outboundSchema: z.ZodType<
  LinkedRecords2$Outbound,
  z.ZodTypeDef,
  LinkedRecords2
> = z.object({
  targetObject: z.string(),
  slugOrIdOfMatchingAttribute: z.array(
    z.union([
      z.lazy(() => SlugOrIdOfMatchingAttribute1$outboundSchema),
      z.lazy(() => SlugOrIdOfMatchingAttribute2$outboundSchema),
      z.lazy(() => Three$outboundSchema),
      z.lazy(() => Five$outboundSchema),
      z.lazy(() => Four$outboundSchema),
    ]),
  ),
}).transform((v) => {
  return remap$(v, {
    targetObject: "target_object",
    slugOrIdOfMatchingAttribute: "[slug_or_id_of_matching_attribute]",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LinkedRecords2$ {
  /** @deprecated use `LinkedRecords2$inboundSchema` instead. */
  export const inboundSchema = LinkedRecords2$inboundSchema;
  /** @deprecated use `LinkedRecords2$outboundSchema` instead. */
  export const outboundSchema = LinkedRecords2$outboundSchema;
  /** @deprecated use `LinkedRecords2$Outbound` instead. */
  export type Outbound = LinkedRecords2$Outbound;
}

export function linkedRecords2ToJSON(linkedRecords2: LinkedRecords2): string {
  return JSON.stringify(LinkedRecords2$outboundSchema.parse(linkedRecords2));
}

export function linkedRecords2FromJSON(
  jsonString: string,
): SafeParseResult<LinkedRecords2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LinkedRecords2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LinkedRecords2' from JSON`,
  );
}

/** @internal */
export const LinkedRecords1$inboundSchema: z.ZodType<
  LinkedRecords1,
  z.ZodTypeDef,
  unknown
> = z.object({
  target_object: z.string(),
  target_record_id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "target_object": "targetObject",
    "target_record_id": "targetRecordId",
  });
});

/** @internal */
export type LinkedRecords1$Outbound = {
  target_object: string;
  target_record_id: string;
};

/** @internal */
export const LinkedRecords1$outboundSchema: z.ZodType<
  LinkedRecords1$Outbound,
  z.ZodTypeDef,
  LinkedRecords1
> = z.object({
  targetObject: z.string(),
  targetRecordId: z.string(),
}).transform((v) => {
  return remap$(v, {
    targetObject: "target_object",
    targetRecordId: "target_record_id",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LinkedRecords1$ {
  /** @deprecated use `LinkedRecords1$inboundSchema` instead. */
  export const inboundSchema = LinkedRecords1$inboundSchema;
  /** @deprecated use `LinkedRecords1$outboundSchema` instead. */
  export const outboundSchema = LinkedRecords1$outboundSchema;
  /** @deprecated use `LinkedRecords1$Outbound` instead. */
  export type Outbound = LinkedRecords1$Outbound;
}

export function linkedRecords1ToJSON(linkedRecords1: LinkedRecords1): string {
  return JSON.stringify(LinkedRecords1$outboundSchema.parse(linkedRecords1));
}

export function linkedRecords1FromJSON(
  jsonString: string,
): SafeParseResult<LinkedRecords1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LinkedRecords1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LinkedRecords1' from JSON`,
  );
}

/** @internal */
export const LinkedRecords$inboundSchema: z.ZodType<
  LinkedRecords,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => LinkedRecords1$inboundSchema),
  z.lazy(() => LinkedRecords2$inboundSchema),
]);

/** @internal */
export type LinkedRecords$Outbound =
  | LinkedRecords1$Outbound
  | LinkedRecords2$Outbound;

/** @internal */
export const LinkedRecords$outboundSchema: z.ZodType<
  LinkedRecords$Outbound,
  z.ZodTypeDef,
  LinkedRecords
> = z.union([
  z.lazy(() => LinkedRecords1$outboundSchema),
  z.lazy(() => LinkedRecords2$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LinkedRecords$ {
  /** @deprecated use `LinkedRecords$inboundSchema` instead. */
  export const inboundSchema = LinkedRecords$inboundSchema;
  /** @deprecated use `LinkedRecords$outboundSchema` instead. */
  export const outboundSchema = LinkedRecords$outboundSchema;
  /** @deprecated use `LinkedRecords$Outbound` instead. */
  export type Outbound = LinkedRecords$Outbound;
}

export function linkedRecordsToJSON(linkedRecords: LinkedRecords): string {
  return JSON.stringify(LinkedRecords$outboundSchema.parse(linkedRecords));
}

export function linkedRecordsFromJSON(
  jsonString: string,
): SafeParseResult<LinkedRecords, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LinkedRecords$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LinkedRecords' from JSON`,
  );
}

/** @internal */
export const Assignees2$inboundSchema: z.ZodType<
  Assignees2,
  z.ZodTypeDef,
  unknown
> = z.object({
  workspace_member_email_address: z.string(),
}).transform((v) => {
  return remap$(v, {
    "workspace_member_email_address": "workspaceMemberEmailAddress",
  });
});

/** @internal */
export type Assignees2$Outbound = {
  workspace_member_email_address: string;
};

/** @internal */
export const Assignees2$outboundSchema: z.ZodType<
  Assignees2$Outbound,
  z.ZodTypeDef,
  Assignees2
> = z.object({
  workspaceMemberEmailAddress: z.string(),
}).transform((v) => {
  return remap$(v, {
    workspaceMemberEmailAddress: "workspace_member_email_address",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Assignees2$ {
  /** @deprecated use `Assignees2$inboundSchema` instead. */
  export const inboundSchema = Assignees2$inboundSchema;
  /** @deprecated use `Assignees2$outboundSchema` instead. */
  export const outboundSchema = Assignees2$outboundSchema;
  /** @deprecated use `Assignees2$Outbound` instead. */
  export type Outbound = Assignees2$Outbound;
}

export function assignees2ToJSON(assignees2: Assignees2): string {
  return JSON.stringify(Assignees2$outboundSchema.parse(assignees2));
}

export function assignees2FromJSON(
  jsonString: string,
): SafeParseResult<Assignees2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Assignees2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Assignees2' from JSON`,
  );
}

/** @internal */
export const ReferencedActorType$inboundSchema: z.ZodNativeEnum<
  typeof ReferencedActorType
> = z.nativeEnum(ReferencedActorType);

/** @internal */
export const ReferencedActorType$outboundSchema: z.ZodNativeEnum<
  typeof ReferencedActorType
> = ReferencedActorType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ReferencedActorType$ {
  /** @deprecated use `ReferencedActorType$inboundSchema` instead. */
  export const inboundSchema = ReferencedActorType$inboundSchema;
  /** @deprecated use `ReferencedActorType$outboundSchema` instead. */
  export const outboundSchema = ReferencedActorType$outboundSchema;
}

/** @internal */
export const Assignees1$inboundSchema: z.ZodType<
  Assignees1,
  z.ZodTypeDef,
  unknown
> = z.object({
  referenced_actor_type: ReferencedActorType$inboundSchema,
  referenced_actor_id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "referenced_actor_type": "referencedActorType",
    "referenced_actor_id": "referencedActorId",
  });
});

/** @internal */
export type Assignees1$Outbound = {
  referenced_actor_type: string;
  referenced_actor_id: string;
};

/** @internal */
export const Assignees1$outboundSchema: z.ZodType<
  Assignees1$Outbound,
  z.ZodTypeDef,
  Assignees1
> = z.object({
  referencedActorType: ReferencedActorType$outboundSchema,
  referencedActorId: z.string(),
}).transform((v) => {
  return remap$(v, {
    referencedActorType: "referenced_actor_type",
    referencedActorId: "referenced_actor_id",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Assignees1$ {
  /** @deprecated use `Assignees1$inboundSchema` instead. */
  export const inboundSchema = Assignees1$inboundSchema;
  /** @deprecated use `Assignees1$outboundSchema` instead. */
  export const outboundSchema = Assignees1$outboundSchema;
  /** @deprecated use `Assignees1$Outbound` instead. */
  export type Outbound = Assignees1$Outbound;
}

export function assignees1ToJSON(assignees1: Assignees1): string {
  return JSON.stringify(Assignees1$outboundSchema.parse(assignees1));
}

export function assignees1FromJSON(
  jsonString: string,
): SafeParseResult<Assignees1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Assignees1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Assignees1' from JSON`,
  );
}

/** @internal */
export const Assignees$inboundSchema: z.ZodType<
  Assignees,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => Assignees2$inboundSchema),
  z.lazy(() => Assignees1$inboundSchema),
]);

/** @internal */
export type Assignees$Outbound = Assignees2$Outbound | Assignees1$Outbound;

/** @internal */
export const Assignees$outboundSchema: z.ZodType<
  Assignees$Outbound,
  z.ZodTypeDef,
  Assignees
> = z.union([
  z.lazy(() => Assignees2$outboundSchema),
  z.lazy(() => Assignees1$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Assignees$ {
  /** @deprecated use `Assignees$inboundSchema` instead. */
  export const inboundSchema = Assignees$inboundSchema;
  /** @deprecated use `Assignees$outboundSchema` instead. */
  export const outboundSchema = Assignees$outboundSchema;
  /** @deprecated use `Assignees$Outbound` instead. */
  export type Outbound = Assignees$Outbound;
}

export function assigneesToJSON(assignees: Assignees): string {
  return JSON.stringify(Assignees$outboundSchema.parse(assignees));
}

export function assigneesFromJSON(
  jsonString: string,
): SafeParseResult<Assignees, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Assignees$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Assignees' from JSON`,
  );
}

/** @internal */
export const PostV2TasksData$inboundSchema: z.ZodType<
  PostV2TasksData,
  z.ZodTypeDef,
  unknown
> = z.object({
  content: z.string(),
  format: PostV2TasksFormat$inboundSchema,
  deadline_at: z.nullable(z.string()),
  is_completed: z.boolean(),
  linked_records: z.array(
    z.union([
      z.lazy(() => LinkedRecords1$inboundSchema),
      z.lazy(() => LinkedRecords2$inboundSchema),
    ]),
  ),
  assignees: z.array(
    z.union([
      z.lazy(() => Assignees2$inboundSchema),
      z.lazy(() => Assignees1$inboundSchema),
    ]),
  ),
}).transform((v) => {
  return remap$(v, {
    "deadline_at": "deadlineAt",
    "is_completed": "isCompleted",
    "linked_records": "linkedRecords",
  });
});

/** @internal */
export type PostV2TasksData$Outbound = {
  content: string;
  format: string;
  deadline_at: string | null;
  is_completed: boolean;
  linked_records: Array<LinkedRecords1$Outbound | LinkedRecords2$Outbound>;
  assignees: Array<Assignees2$Outbound | Assignees1$Outbound>;
};

/** @internal */
export const PostV2TasksData$outboundSchema: z.ZodType<
  PostV2TasksData$Outbound,
  z.ZodTypeDef,
  PostV2TasksData
> = z.object({
  content: z.string(),
  format: PostV2TasksFormat$outboundSchema,
  deadlineAt: z.nullable(z.string()),
  isCompleted: z.boolean(),
  linkedRecords: z.array(
    z.union([
      z.lazy(() => LinkedRecords1$outboundSchema),
      z.lazy(() => LinkedRecords2$outboundSchema),
    ]),
  ),
  assignees: z.array(
    z.union([
      z.lazy(() => Assignees2$outboundSchema),
      z.lazy(() => Assignees1$outboundSchema),
    ]),
  ),
}).transform((v) => {
  return remap$(v, {
    deadlineAt: "deadline_at",
    isCompleted: "is_completed",
    linkedRecords: "linked_records",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PostV2TasksData$ {
  /** @deprecated use `PostV2TasksData$inboundSchema` instead. */
  export const inboundSchema = PostV2TasksData$inboundSchema;
  /** @deprecated use `PostV2TasksData$outboundSchema` instead. */
  export const outboundSchema = PostV2TasksData$outboundSchema;
  /** @deprecated use `PostV2TasksData$Outbound` instead. */
  export type Outbound = PostV2TasksData$Outbound;
}

export function postV2TasksDataToJSON(
  postV2TasksData: PostV2TasksData,
): string {
  return JSON.stringify(PostV2TasksData$outboundSchema.parse(postV2TasksData));
}

export function postV2TasksDataFromJSON(
  jsonString: string,
): SafeParseResult<PostV2TasksData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PostV2TasksData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PostV2TasksData' from JSON`,
  );
}

/** @internal */
export const PostV2TasksRequestBody$inboundSchema: z.ZodType<
  PostV2TasksRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  data: z.lazy(() => PostV2TasksData$inboundSchema),
});

/** @internal */
export type PostV2TasksRequestBody$Outbound = {
  data: PostV2TasksData$Outbound;
};

/** @internal */
export const PostV2TasksRequestBody$outboundSchema: z.ZodType<
  PostV2TasksRequestBody$Outbound,
  z.ZodTypeDef,
  PostV2TasksRequestBody
> = z.object({
  data: z.lazy(() => PostV2TasksData$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PostV2TasksRequestBody$ {
  /** @deprecated use `PostV2TasksRequestBody$inboundSchema` instead. */
  export const inboundSchema = PostV2TasksRequestBody$inboundSchema;
  /** @deprecated use `PostV2TasksRequestBody$outboundSchema` instead. */
  export const outboundSchema = PostV2TasksRequestBody$outboundSchema;
  /** @deprecated use `PostV2TasksRequestBody$Outbound` instead. */
  export type Outbound = PostV2TasksRequestBody$Outbound;
}

export function postV2TasksRequestBodyToJSON(
  postV2TasksRequestBody: PostV2TasksRequestBody,
): string {
  return JSON.stringify(
    PostV2TasksRequestBody$outboundSchema.parse(postV2TasksRequestBody),
  );
}

export function postV2TasksRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<PostV2TasksRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PostV2TasksRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PostV2TasksRequestBody' from JSON`,
  );
}

/** @internal */
export const PostV2TasksResponseBody$inboundSchema: z.ZodType<
  PostV2TasksResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  data: components.Task$inboundSchema,
});

/** @internal */
export type PostV2TasksResponseBody$Outbound = {
  data: components.Task$Outbound;
};

/** @internal */
export const PostV2TasksResponseBody$outboundSchema: z.ZodType<
  PostV2TasksResponseBody$Outbound,
  z.ZodTypeDef,
  PostV2TasksResponseBody
> = z.object({
  data: components.Task$outboundSchema,
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PostV2TasksResponseBody$ {
  /** @deprecated use `PostV2TasksResponseBody$inboundSchema` instead. */
  export const inboundSchema = PostV2TasksResponseBody$inboundSchema;
  /** @deprecated use `PostV2TasksResponseBody$outboundSchema` instead. */
  export const outboundSchema = PostV2TasksResponseBody$outboundSchema;
  /** @deprecated use `PostV2TasksResponseBody$Outbound` instead. */
  export type Outbound = PostV2TasksResponseBody$Outbound;
}

export function postV2TasksResponseBodyToJSON(
  postV2TasksResponseBody: PostV2TasksResponseBody,
): string {
  return JSON.stringify(
    PostV2TasksResponseBody$outboundSchema.parse(postV2TasksResponseBody),
  );
}

export function postV2TasksResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<PostV2TasksResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PostV2TasksResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PostV2TasksResponseBody' from JSON`,
  );
}
