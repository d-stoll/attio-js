/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  OutputValue,
  OutputValue$inboundSchema,
  OutputValue$Outbound,
  OutputValue$outboundSchema,
} from "./outputvalue.js";

export type AttributeId = {
  /**
   * A UUID representing the workspace this attribute belongs to.
   */
  workspaceId: string;
  /**
   * A UUID to identify the object or list that this attribute belongs to
   */
  objectId: string;
  /**
   * A UUID to identify this attribute.
   */
  attributeId: string;
};

/**
 * The type of the attribute.
 */
export const Type = {
  Text: "text",
  Number: "number",
  Checkbox: "checkbox",
  Currency: "currency",
  Date: "date",
  Timestamp: "timestamp",
  Rating: "rating",
  Status: "status",
  Select: "select",
  RecordReference: "record-reference",
  ActorReference: "actor-reference",
  Location: "location",
  Domain: "domain",
  EmailAddress: "email-address",
  PhoneNumber: "phone-number",
  Interaction: "interaction",
  PersonalName: "personal-name",
} as const;
/**
 * The type of the attribute.
 */
export type Type = ClosedEnum<typeof Type>;

export const AttributeDefaultValueType = {
  Static: "static",
} as const;
export type AttributeDefaultValueType = ClosedEnum<
  typeof AttributeDefaultValueType
>;

export type Two = {
  type: AttributeDefaultValueType;
  template: Array<OutputValue>;
};

export const DefaultValueType = {
  Dynamic: "dynamic",
} as const;
export type DefaultValueType = ClosedEnum<typeof DefaultValueType>;

/**
 * For actor reference attributes, you may pass a dynamic value of `"current-user"`. When creating new records or entries, this will cause the actor reference value to be populated with either the workspace member or API token that created the record/entry.
 */
export const Template1 = {
  CurrentUser: "current-user",
} as const;
/**
 * For actor reference attributes, you may pass a dynamic value of `"current-user"`. When creating new records or entries, this will cause the actor reference value to be populated with either the workspace member or API token that created the record/entry.
 */
export type Template1 = ClosedEnum<typeof Template1>;

export type One = {
  type: DefaultValueType;
  template?: any | undefined;
};

/**
 * The default value for this attribute. Static values are used to directly populate values using their contents. Dynamic values are used to lookup data at the point of creation. For example, you could use a dynamic value to insert a value for the currently logged in user. Which default values are available is dependent on the type of the attribute.
 */
export type DefaultValue = One | Two;

export type AttributeRelationshipId = {
  /**
   * A UUID representing the workspace this attribute belongs to.
   */
  workspaceId: string;
  /**
   * A UUID to identify the object or list that this attribute belongs to
   */
  objectId: string;
  /**
   * A UUID to identify this attribute.
   */
  attributeId: string;
};

/**
 * If this attribute is related to another attribute, this is an object that includes an `id` property that identifies the other attribute. `null` means no relationship exists. See [the help center](https://attio.com/help/reference/managing-your-data/attributes#relationship-attributes) for more details about relationship attributes.
 */
export type Relationship = {
  id: AttributeRelationshipId;
};

/**
 * The ISO4217 code representing the currency that values for this attribute should be stored in.
 */
export const DefaultCurrencyCode = {
  Aud: "AUD",
  Brl: "BRL",
  Bel: "BEL",
  Cad: "CAD",
  Cny: "CNY",
  Cop: "COP",
  Czk: "CZK",
  Dkk: "DKK",
  Eur: "EUR",
  Hkd: "HKD",
  Isk: "ISK",
  Inr: "INR",
  Ils: "ILS",
  Jpy: "JPY",
  Krw: "KRW",
  Myr: "MYR",
  Mxn: "MXN",
  Ntd: "NTD",
  Nzd: "NZD",
  Ngn: "NGN",
  Nok: "NOK",
  Xpf: "XPF",
  Pen: "PEN",
  Php: "PHP",
  Pln: "PLN",
  Gbp: "GBP",
  Sar: "SAR",
  Sgd: "SGD",
  Zar: "ZAR",
  Sek: "SEK",
  Chf: "CHF",
  Aed: "AED",
  Usd: "USD",
} as const;
/**
 * The ISO4217 code representing the currency that values for this attribute should be stored in.
 */
export type DefaultCurrencyCode = ClosedEnum<typeof DefaultCurrencyCode>;

/**
 * How the currency should be displayed across the app. "code" will display the ISO currency code e.g. "USD", "name" will display the localized currency name e.g. "British pound", "narrowSymbol" will display "$1" instead of "US$1" and "symbol" will display a localized currency symbol such as "$".
 */
export const DisplayType = {
  Code: "code",
  Name: "name",
  NarrowSymbol: "narrowSymbol",
  Symbol: "symbol",
} as const;
/**
 * How the currency should be displayed across the app. "code" will display the ISO currency code e.g. "USD", "name" will display the localized currency name e.g. "British pound", "narrowSymbol" will display "$1" instead of "US$1" and "symbol" will display a localized currency symbol such as "$".
 */
export type DisplayType = ClosedEnum<typeof DisplayType>;

/**
 * Configuration available for attributes of type "currency".
 */
export type Currency = {
  /**
   * The ISO4217 code representing the currency that values for this attribute should be stored in.
   */
  defaultCurrencyCode: DefaultCurrencyCode | null;
  /**
   * How the currency should be displayed across the app. "code" will display the ISO currency code e.g. "USD", "name" will display the localized currency name e.g. "British pound", "narrowSymbol" will display "$1" instead of "US$1" and "symbol" will display a localized currency symbol such as "$".
   */
  displayType: DisplayType | null;
};

/**
 * Configuration available for attributes of type "record-reference".
 */
export type RecordReference = {
  /**
   * A list of UUIDs to indicate which objects records are allowed to belong to. Leave empty to to allow records from all object types.
   */
  allowedObjectIds: Array<string> | null;
};

/**
 * Additional, type-dependent configuration for the attribute.
 */
export type Config = {
  /**
   * Configuration available for attributes of type "currency".
   */
  currency: Currency;
  /**
   * Configuration available for attributes of type "record-reference".
   */
  recordReference: RecordReference;
};

export type Attribute = {
  id: AttributeId;
  /**
   * A title for the attribute, to be displayed across the app.
   */
  title: string;
  /**
   * A text description of the attribute.
   */
  description: string | null;
  /**
   * A unique slug for the attribute for use in API responses and URLs. Formatted in snake case.
   */
  apiSlug: string;
  /**
   * The type of the attribute.
   */
  type: Type;
  /**
   * `true` if this is an Attio system-defined attribute, `false` if defined by a user or non-Attio system.
   */
  isSystemAttribute: boolean;
  /**
   * Whether or not this attribute can be written to. Can only be false when `is_system_attribute` is `true` (user-defined attributes are always writeable). If `false`, this usually means the attribute is enriched by Attio.
   */
  isWritable: boolean;
  /**
   * When `is_required` is `true`, new records/entries must have a value for this attribute. If `false`, values may be `null`. This value does not affect existing data and you do not need to backfill `null` values if changing `is_required` from `false` to `true`.
   */
  isRequired: boolean;
  /**
   * Whether or not new values for this attribute must be unique. Uniqueness restrictions are only applied to new data and do not apply retroactively to previously created data.
   */
  isUnique: boolean;
  /**
   * Whether or not this attribute can have multiple values. Multiselect is only available on some value types.
   */
  isMultiselect: boolean;
  /**
   * Whether this attribute has a default value enabled. Must be `true` when `is_required` is `true`.
   */
  isDefaultValueEnabled: boolean;
  /**
   * Whether this attribute has been archived. Archived attributes are hidden from most UI, but can be restored either over the API or in workspace settings. See the [guide on archiving and deleting](/docs/archiving-vs-deleting)for more information.
   */
  isArchived: boolean;
  /**
   * The default value for this attribute. Static values are used to directly populate values using their contents. Dynamic values are used to lookup data at the point of creation. For example, you could use a dynamic value to insert a value for the currently logged in user. Which default values are available is dependent on the type of the attribute.
   */
  defaultValue: One | Two | null;
  /**
   * If this attribute is related to another attribute, this is an object that includes an `id` property that identifies the other attribute. `null` means no relationship exists. See [the help center](https://attio.com/help/reference/managing-your-data/attributes#relationship-attributes) for more details about relationship attributes.
   */
  relationship: Relationship | null;
  /**
   * When this attribute was created.
   */
  createdAt: string;
  /**
   * Additional, type-dependent configuration for the attribute.
   */
  config: Config;
};

/** @internal */
export const AttributeId$inboundSchema: z.ZodType<
  AttributeId,
  z.ZodTypeDef,
  unknown
> = z.object({
  workspace_id: z.string(),
  object_id: z.string(),
  attribute_id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "workspace_id": "workspaceId",
    "object_id": "objectId",
    "attribute_id": "attributeId",
  });
});

/** @internal */
export type AttributeId$Outbound = {
  workspace_id: string;
  object_id: string;
  attribute_id: string;
};

/** @internal */
export const AttributeId$outboundSchema: z.ZodType<
  AttributeId$Outbound,
  z.ZodTypeDef,
  AttributeId
> = z.object({
  workspaceId: z.string(),
  objectId: z.string(),
  attributeId: z.string(),
}).transform((v) => {
  return remap$(v, {
    workspaceId: "workspace_id",
    objectId: "object_id",
    attributeId: "attribute_id",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AttributeId$ {
  /** @deprecated use `AttributeId$inboundSchema` instead. */
  export const inboundSchema = AttributeId$inboundSchema;
  /** @deprecated use `AttributeId$outboundSchema` instead. */
  export const outboundSchema = AttributeId$outboundSchema;
  /** @deprecated use `AttributeId$Outbound` instead. */
  export type Outbound = AttributeId$Outbound;
}

export function attributeIdToJSON(attributeId: AttributeId): string {
  return JSON.stringify(AttributeId$outboundSchema.parse(attributeId));
}

export function attributeIdFromJSON(
  jsonString: string,
): SafeParseResult<AttributeId, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AttributeId$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AttributeId' from JSON`,
  );
}

/** @internal */
export const Type$inboundSchema: z.ZodNativeEnum<typeof Type> = z.nativeEnum(
  Type,
);

/** @internal */
export const Type$outboundSchema: z.ZodNativeEnum<typeof Type> =
  Type$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Type$ {
  /** @deprecated use `Type$inboundSchema` instead. */
  export const inboundSchema = Type$inboundSchema;
  /** @deprecated use `Type$outboundSchema` instead. */
  export const outboundSchema = Type$outboundSchema;
}

/** @internal */
export const AttributeDefaultValueType$inboundSchema: z.ZodNativeEnum<
  typeof AttributeDefaultValueType
> = z.nativeEnum(AttributeDefaultValueType);

/** @internal */
export const AttributeDefaultValueType$outboundSchema: z.ZodNativeEnum<
  typeof AttributeDefaultValueType
> = AttributeDefaultValueType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AttributeDefaultValueType$ {
  /** @deprecated use `AttributeDefaultValueType$inboundSchema` instead. */
  export const inboundSchema = AttributeDefaultValueType$inboundSchema;
  /** @deprecated use `AttributeDefaultValueType$outboundSchema` instead. */
  export const outboundSchema = AttributeDefaultValueType$outboundSchema;
}

/** @internal */
export const Two$inboundSchema: z.ZodType<Two, z.ZodTypeDef, unknown> = z
  .object({
    type: AttributeDefaultValueType$inboundSchema,
    template: z.array(OutputValue$inboundSchema),
  });

/** @internal */
export type Two$Outbound = {
  type: string;
  template: Array<OutputValue$Outbound>;
};

/** @internal */
export const Two$outboundSchema: z.ZodType<Two$Outbound, z.ZodTypeDef, Two> = z
  .object({
    type: AttributeDefaultValueType$outboundSchema,
    template: z.array(OutputValue$outboundSchema),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Two$ {
  /** @deprecated use `Two$inboundSchema` instead. */
  export const inboundSchema = Two$inboundSchema;
  /** @deprecated use `Two$outboundSchema` instead. */
  export const outboundSchema = Two$outboundSchema;
  /** @deprecated use `Two$Outbound` instead. */
  export type Outbound = Two$Outbound;
}

export function twoToJSON(two: Two): string {
  return JSON.stringify(Two$outboundSchema.parse(two));
}

export function twoFromJSON(
  jsonString: string,
): SafeParseResult<Two, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Two$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Two' from JSON`,
  );
}

/** @internal */
export const DefaultValueType$inboundSchema: z.ZodNativeEnum<
  typeof DefaultValueType
> = z.nativeEnum(DefaultValueType);

/** @internal */
export const DefaultValueType$outboundSchema: z.ZodNativeEnum<
  typeof DefaultValueType
> = DefaultValueType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DefaultValueType$ {
  /** @deprecated use `DefaultValueType$inboundSchema` instead. */
  export const inboundSchema = DefaultValueType$inboundSchema;
  /** @deprecated use `DefaultValueType$outboundSchema` instead. */
  export const outboundSchema = DefaultValueType$outboundSchema;
}

/** @internal */
export const Template1$inboundSchema: z.ZodNativeEnum<typeof Template1> = z
  .nativeEnum(Template1);

/** @internal */
export const Template1$outboundSchema: z.ZodNativeEnum<typeof Template1> =
  Template1$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Template1$ {
  /** @deprecated use `Template1$inboundSchema` instead. */
  export const inboundSchema = Template1$inboundSchema;
  /** @deprecated use `Template1$outboundSchema` instead. */
  export const outboundSchema = Template1$outboundSchema;
}

/** @internal */
export const One$inboundSchema: z.ZodType<One, z.ZodTypeDef, unknown> = z
  .object({
    type: DefaultValueType$inboundSchema,
    template: z.any().optional(),
  });

/** @internal */
export type One$Outbound = {
  type: string;
  template?: any | undefined;
};

/** @internal */
export const One$outboundSchema: z.ZodType<One$Outbound, z.ZodTypeDef, One> = z
  .object({
    type: DefaultValueType$outboundSchema,
    template: z.any().optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace One$ {
  /** @deprecated use `One$inboundSchema` instead. */
  export const inboundSchema = One$inboundSchema;
  /** @deprecated use `One$outboundSchema` instead. */
  export const outboundSchema = One$outboundSchema;
  /** @deprecated use `One$Outbound` instead. */
  export type Outbound = One$Outbound;
}

export function oneToJSON(one: One): string {
  return JSON.stringify(One$outboundSchema.parse(one));
}

export function oneFromJSON(
  jsonString: string,
): SafeParseResult<One, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => One$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'One' from JSON`,
  );
}

/** @internal */
export const DefaultValue$inboundSchema: z.ZodType<
  DefaultValue,
  z.ZodTypeDef,
  unknown
> = z.union([z.lazy(() => One$inboundSchema), z.lazy(() => Two$inboundSchema)]);

/** @internal */
export type DefaultValue$Outbound = One$Outbound | Two$Outbound;

/** @internal */
export const DefaultValue$outboundSchema: z.ZodType<
  DefaultValue$Outbound,
  z.ZodTypeDef,
  DefaultValue
> = z.union([
  z.lazy(() => One$outboundSchema),
  z.lazy(() => Two$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DefaultValue$ {
  /** @deprecated use `DefaultValue$inboundSchema` instead. */
  export const inboundSchema = DefaultValue$inboundSchema;
  /** @deprecated use `DefaultValue$outboundSchema` instead. */
  export const outboundSchema = DefaultValue$outboundSchema;
  /** @deprecated use `DefaultValue$Outbound` instead. */
  export type Outbound = DefaultValue$Outbound;
}

export function defaultValueToJSON(defaultValue: DefaultValue): string {
  return JSON.stringify(DefaultValue$outboundSchema.parse(defaultValue));
}

export function defaultValueFromJSON(
  jsonString: string,
): SafeParseResult<DefaultValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DefaultValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DefaultValue' from JSON`,
  );
}

/** @internal */
export const AttributeRelationshipId$inboundSchema: z.ZodType<
  AttributeRelationshipId,
  z.ZodTypeDef,
  unknown
> = z.object({
  workspace_id: z.string(),
  object_id: z.string(),
  attribute_id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "workspace_id": "workspaceId",
    "object_id": "objectId",
    "attribute_id": "attributeId",
  });
});

/** @internal */
export type AttributeRelationshipId$Outbound = {
  workspace_id: string;
  object_id: string;
  attribute_id: string;
};

/** @internal */
export const AttributeRelationshipId$outboundSchema: z.ZodType<
  AttributeRelationshipId$Outbound,
  z.ZodTypeDef,
  AttributeRelationshipId
> = z.object({
  workspaceId: z.string(),
  objectId: z.string(),
  attributeId: z.string(),
}).transform((v) => {
  return remap$(v, {
    workspaceId: "workspace_id",
    objectId: "object_id",
    attributeId: "attribute_id",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AttributeRelationshipId$ {
  /** @deprecated use `AttributeRelationshipId$inboundSchema` instead. */
  export const inboundSchema = AttributeRelationshipId$inboundSchema;
  /** @deprecated use `AttributeRelationshipId$outboundSchema` instead. */
  export const outboundSchema = AttributeRelationshipId$outboundSchema;
  /** @deprecated use `AttributeRelationshipId$Outbound` instead. */
  export type Outbound = AttributeRelationshipId$Outbound;
}

export function attributeRelationshipIdToJSON(
  attributeRelationshipId: AttributeRelationshipId,
): string {
  return JSON.stringify(
    AttributeRelationshipId$outboundSchema.parse(attributeRelationshipId),
  );
}

export function attributeRelationshipIdFromJSON(
  jsonString: string,
): SafeParseResult<AttributeRelationshipId, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AttributeRelationshipId$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AttributeRelationshipId' from JSON`,
  );
}

/** @internal */
export const Relationship$inboundSchema: z.ZodType<
  Relationship,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.lazy(() => AttributeRelationshipId$inboundSchema),
});

/** @internal */
export type Relationship$Outbound = {
  id: AttributeRelationshipId$Outbound;
};

/** @internal */
export const Relationship$outboundSchema: z.ZodType<
  Relationship$Outbound,
  z.ZodTypeDef,
  Relationship
> = z.object({
  id: z.lazy(() => AttributeRelationshipId$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Relationship$ {
  /** @deprecated use `Relationship$inboundSchema` instead. */
  export const inboundSchema = Relationship$inboundSchema;
  /** @deprecated use `Relationship$outboundSchema` instead. */
  export const outboundSchema = Relationship$outboundSchema;
  /** @deprecated use `Relationship$Outbound` instead. */
  export type Outbound = Relationship$Outbound;
}

export function relationshipToJSON(relationship: Relationship): string {
  return JSON.stringify(Relationship$outboundSchema.parse(relationship));
}

export function relationshipFromJSON(
  jsonString: string,
): SafeParseResult<Relationship, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Relationship$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Relationship' from JSON`,
  );
}

/** @internal */
export const DefaultCurrencyCode$inboundSchema: z.ZodNativeEnum<
  typeof DefaultCurrencyCode
> = z.nativeEnum(DefaultCurrencyCode);

/** @internal */
export const DefaultCurrencyCode$outboundSchema: z.ZodNativeEnum<
  typeof DefaultCurrencyCode
> = DefaultCurrencyCode$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DefaultCurrencyCode$ {
  /** @deprecated use `DefaultCurrencyCode$inboundSchema` instead. */
  export const inboundSchema = DefaultCurrencyCode$inboundSchema;
  /** @deprecated use `DefaultCurrencyCode$outboundSchema` instead. */
  export const outboundSchema = DefaultCurrencyCode$outboundSchema;
}

/** @internal */
export const DisplayType$inboundSchema: z.ZodNativeEnum<typeof DisplayType> = z
  .nativeEnum(DisplayType);

/** @internal */
export const DisplayType$outboundSchema: z.ZodNativeEnum<typeof DisplayType> =
  DisplayType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DisplayType$ {
  /** @deprecated use `DisplayType$inboundSchema` instead. */
  export const inboundSchema = DisplayType$inboundSchema;
  /** @deprecated use `DisplayType$outboundSchema` instead. */
  export const outboundSchema = DisplayType$outboundSchema;
}

/** @internal */
export const Currency$inboundSchema: z.ZodType<
  Currency,
  z.ZodTypeDef,
  unknown
> = z.object({
  default_currency_code: z.nullable(DefaultCurrencyCode$inboundSchema),
  display_type: z.nullable(DisplayType$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "default_currency_code": "defaultCurrencyCode",
    "display_type": "displayType",
  });
});

/** @internal */
export type Currency$Outbound = {
  default_currency_code: string | null;
  display_type: string | null;
};

/** @internal */
export const Currency$outboundSchema: z.ZodType<
  Currency$Outbound,
  z.ZodTypeDef,
  Currency
> = z.object({
  defaultCurrencyCode: z.nullable(DefaultCurrencyCode$outboundSchema),
  displayType: z.nullable(DisplayType$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    defaultCurrencyCode: "default_currency_code",
    displayType: "display_type",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Currency$ {
  /** @deprecated use `Currency$inboundSchema` instead. */
  export const inboundSchema = Currency$inboundSchema;
  /** @deprecated use `Currency$outboundSchema` instead. */
  export const outboundSchema = Currency$outboundSchema;
  /** @deprecated use `Currency$Outbound` instead. */
  export type Outbound = Currency$Outbound;
}

export function currencyToJSON(currency: Currency): string {
  return JSON.stringify(Currency$outboundSchema.parse(currency));
}

export function currencyFromJSON(
  jsonString: string,
): SafeParseResult<Currency, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Currency$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Currency' from JSON`,
  );
}

/** @internal */
export const RecordReference$inboundSchema: z.ZodType<
  RecordReference,
  z.ZodTypeDef,
  unknown
> = z.object({
  allowed_object_ids: z.nullable(z.array(z.string())),
}).transform((v) => {
  return remap$(v, {
    "allowed_object_ids": "allowedObjectIds",
  });
});

/** @internal */
export type RecordReference$Outbound = {
  allowed_object_ids: Array<string> | null;
};

/** @internal */
export const RecordReference$outboundSchema: z.ZodType<
  RecordReference$Outbound,
  z.ZodTypeDef,
  RecordReference
> = z.object({
  allowedObjectIds: z.nullable(z.array(z.string())),
}).transform((v) => {
  return remap$(v, {
    allowedObjectIds: "allowed_object_ids",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RecordReference$ {
  /** @deprecated use `RecordReference$inboundSchema` instead. */
  export const inboundSchema = RecordReference$inboundSchema;
  /** @deprecated use `RecordReference$outboundSchema` instead. */
  export const outboundSchema = RecordReference$outboundSchema;
  /** @deprecated use `RecordReference$Outbound` instead. */
  export type Outbound = RecordReference$Outbound;
}

export function recordReferenceToJSON(
  recordReference: RecordReference,
): string {
  return JSON.stringify(RecordReference$outboundSchema.parse(recordReference));
}

export function recordReferenceFromJSON(
  jsonString: string,
): SafeParseResult<RecordReference, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RecordReference$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RecordReference' from JSON`,
  );
}

/** @internal */
export const Config$inboundSchema: z.ZodType<Config, z.ZodTypeDef, unknown> = z
  .object({
    currency: z.lazy(() => Currency$inboundSchema),
    record_reference: z.lazy(() => RecordReference$inboundSchema),
  }).transform((v) => {
    return remap$(v, {
      "record_reference": "recordReference",
    });
  });

/** @internal */
export type Config$Outbound = {
  currency: Currency$Outbound;
  record_reference: RecordReference$Outbound;
};

/** @internal */
export const Config$outboundSchema: z.ZodType<
  Config$Outbound,
  z.ZodTypeDef,
  Config
> = z.object({
  currency: z.lazy(() => Currency$outboundSchema),
  recordReference: z.lazy(() => RecordReference$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    recordReference: "record_reference",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Config$ {
  /** @deprecated use `Config$inboundSchema` instead. */
  export const inboundSchema = Config$inboundSchema;
  /** @deprecated use `Config$outboundSchema` instead. */
  export const outboundSchema = Config$outboundSchema;
  /** @deprecated use `Config$Outbound` instead. */
  export type Outbound = Config$Outbound;
}

export function configToJSON(config: Config): string {
  return JSON.stringify(Config$outboundSchema.parse(config));
}

export function configFromJSON(
  jsonString: string,
): SafeParseResult<Config, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Config$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Config' from JSON`,
  );
}

/** @internal */
export const Attribute$inboundSchema: z.ZodType<
  Attribute,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.lazy(() => AttributeId$inboundSchema),
  title: z.string(),
  description: z.nullable(z.string()),
  api_slug: z.string(),
  type: Type$inboundSchema,
  is_system_attribute: z.boolean(),
  is_writable: z.boolean(),
  is_required: z.boolean(),
  is_unique: z.boolean(),
  is_multiselect: z.boolean(),
  is_default_value_enabled: z.boolean(),
  is_archived: z.boolean(),
  default_value: z.nullable(
    z.union([z.lazy(() => One$inboundSchema), z.lazy(() => Two$inboundSchema)]),
  ),
  relationship: z.nullable(z.lazy(() => Relationship$inboundSchema)),
  created_at: z.string(),
  config: z.lazy(() => Config$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "api_slug": "apiSlug",
    "is_system_attribute": "isSystemAttribute",
    "is_writable": "isWritable",
    "is_required": "isRequired",
    "is_unique": "isUnique",
    "is_multiselect": "isMultiselect",
    "is_default_value_enabled": "isDefaultValueEnabled",
    "is_archived": "isArchived",
    "default_value": "defaultValue",
    "created_at": "createdAt",
  });
});

/** @internal */
export type Attribute$Outbound = {
  id: AttributeId$Outbound;
  title: string;
  description: string | null;
  api_slug: string;
  type: string;
  is_system_attribute: boolean;
  is_writable: boolean;
  is_required: boolean;
  is_unique: boolean;
  is_multiselect: boolean;
  is_default_value_enabled: boolean;
  is_archived: boolean;
  default_value: One$Outbound | Two$Outbound | null;
  relationship: Relationship$Outbound | null;
  created_at: string;
  config: Config$Outbound;
};

/** @internal */
export const Attribute$outboundSchema: z.ZodType<
  Attribute$Outbound,
  z.ZodTypeDef,
  Attribute
> = z.object({
  id: z.lazy(() => AttributeId$outboundSchema),
  title: z.string(),
  description: z.nullable(z.string()),
  apiSlug: z.string(),
  type: Type$outboundSchema,
  isSystemAttribute: z.boolean(),
  isWritable: z.boolean(),
  isRequired: z.boolean(),
  isUnique: z.boolean(),
  isMultiselect: z.boolean(),
  isDefaultValueEnabled: z.boolean(),
  isArchived: z.boolean(),
  defaultValue: z.nullable(
    z.union([
      z.lazy(() => One$outboundSchema),
      z.lazy(() => Two$outboundSchema),
    ]),
  ),
  relationship: z.nullable(z.lazy(() => Relationship$outboundSchema)),
  createdAt: z.string(),
  config: z.lazy(() => Config$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    apiSlug: "api_slug",
    isSystemAttribute: "is_system_attribute",
    isWritable: "is_writable",
    isRequired: "is_required",
    isUnique: "is_unique",
    isMultiselect: "is_multiselect",
    isDefaultValueEnabled: "is_default_value_enabled",
    isArchived: "is_archived",
    defaultValue: "default_value",
    createdAt: "created_at",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Attribute$ {
  /** @deprecated use `Attribute$inboundSchema` instead. */
  export const inboundSchema = Attribute$inboundSchema;
  /** @deprecated use `Attribute$outboundSchema` instead. */
  export const outboundSchema = Attribute$outboundSchema;
  /** @deprecated use `Attribute$Outbound` instead. */
  export type Outbound = Attribute$Outbound;
}

export function attributeToJSON(attribute: Attribute): string {
  return JSON.stringify(Attribute$outboundSchema.parse(attribute));
}

export function attributeFromJSON(
  jsonString: string,
): SafeParseResult<Attribute, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Attribute$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Attribute' from JSON`,
  );
}
